<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第一个Mybatis程序</title>
      <link href="/2022/10/01/mybatis%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8/"/>
      <url>/2022/10/01/mybatis%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="2、第一个mybatis程序"><a href="#2、第一个mybatis程序" class="headerlink" title="2、第一个mybatis程序"></a>2、第一个mybatis程序</h3><p>思路：搭建环境—&gt;导入Mybatis—&gt;编写代码—&gt;测试</p><h4 id="2-1、搭建环境"><a href="#2-1、搭建环境" class="headerlink" title="2.1、搭建环境"></a>2.1、搭建环境</h4><p>1、搭建数据库</p><p>2、新建项目</p><p> 1、新建普通的maven项目</p><p> 2、删除src目录</p><p> 3、导入maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.carrot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Mybatis-Study<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--    父工程--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2、创建一个模块"><a href="#2-2、创建一个模块" class="headerlink" title="2.2、创建一个模块"></a>2.2、创建一个模块</h4><ul><li><h5 id="编写mybatis的核心配置文件"><a href="#编写mybatis的核心配置文件" class="headerlink" title="编写mybatis的核心配置文件"></a>编写mybatis的核心配置文件</h5></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><h5 id="编写mybatis工具类"><a href="#编写mybatis工具类" class="headerlink" title="编写mybatis工具类"></a>编写mybatis工具类</h5></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.carrot.utils;</span><br><span class="line"></span><br><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class MybatisUtils &#123;</span><br><span class="line"></span><br><span class="line">    String resource = &quot;mybatis-config.xml&quot;;</span><br><span class="line">    private static SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //使用mybatis第一步</span><br><span class="line">            InputStream  inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">             sqlSessionFactory = new SqlSessionFactoryBuilder ().build(inputStream);</span><br><span class="line">//不需要重新再用sqlSessionFactory 定义  这样会出现空指针异常</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace ();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *     获取session实例</span><br><span class="line">     */</span><br><span class="line">    public static SqlSession getSqlSession()&#123;</span><br><span class="line">        return  sqlSessionFactory.openSession ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3、编写代码"><a href="#2-3、编写代码" class="headerlink" title="2.3、编写代码"></a>2.3、编写代码</h4><ul><li>实体类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name, String pwd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPwd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPwd</span><span class="params">(String pwd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Dao接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">getUserList</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口实现类由原来的UserDaoImpl转变为一个Mapper配置文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  namespace 绑定一个对应的Dao/Mapper接口--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.carrot.dao.UserDao&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--select查询语句--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.carrot.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.4、测试</p><ul><li>junit测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取sqlSession</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MybatisUtils.getSqlSession ();</span><br><span class="line"></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper (UserDao.class);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; userList = mapper.getUserList ();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println (user.getName ());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭sqlSession</span></span><br><span class="line">        sqlSession.close ();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能会遇到的错误：</p><p>1、配置文件没有注册</p><p>2、绑定接口问题</p><p>3、方法名不对</p><p>4、返回类型不对</p><p>5、maven导出资源问题</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis-简介</title>
      <link href="/2022/10/01/mybatis-%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/10/01/mybatis-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><h4 id="1-1、什么是Mybatis"><a href="#1-1、什么是Mybatis" class="headerlink" title="1.1、什么是Mybatis"></a>1.1、什么是Mybatis</h4><ul><li>MyBatis 是一款优秀的<strong>持久层框架</strong></li><li>它支持自定义 SQL、存储过程以及高级映射</li><li>MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作</li><li>MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</li><li>MyBatis本是apache的一个<a href="https://baike.baidu.com/item/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/3406069">开源项目</a>iBatis</li><li>2010年这个<a href="https://baike.baidu.com/item/%E9%A1%B9%E7%9B%AE/477803">项目</a>由apache software foundation迁移到了[google code](<a href="https://baike.baidu.com/item/google">https://baike.baidu.com/item/google</a> code&#x2F;2346604)，并且改名为MyBatis。</li><li>2013年11月迁移到<a href="https://baike.baidu.com/item/Github/10145341">Github</a>。</li></ul><p>xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-2、持久化"><a href="#1-2、持久化" class="headerlink" title="1.2、持久化"></a>1.2、持久化</h4><p>数据持久化</p><ul><li>持久化就是将程序的数据在持久状态和瞬间状态转化的过程</li><li>内存：断电即失</li><li>数据库（jdbc），io文件持久化</li><li>生活：冷藏 、罐头</li></ul><p>为什么需要持久化？</p><ul><li>有一些对象不能让它丢掉。</li><li>内存太贵了</li></ul><h4 id="1-3、持久层"><a href="#1-3、持久层" class="headerlink" title="1.3、持久层"></a>1.3、持久层</h4><p>Dao层，service层，Controller层…</p><ul><li>完成持久化工作的代码块</li><li>层界十分明显</li></ul><h4 id="1-4、为什么需要Mybatis"><a href="#1-4、为什么需要Mybatis" class="headerlink" title="1.4、为什么需要Mybatis"></a>1.4、为什么需要Mybatis</h4><ul><li>帮助程序员将数据存入数据库中</li><li>方便</li><li>传统的JDBC代码太复杂了，简化 框架 自动化</li><li>不用mybatis也可以，mybatis更容易上手。技术没有高低之分</li><li>优点<ul><li>简单易学</li><li>灵活</li><li>sql和代码的分离，提高了可维护性。</li><li>提供映射标签，支持对象关系组建维护。</li><li>提供xml标签，支持编写动态sql。</li></ul></li></ul><p>最重要的一点，使用人数多！</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.9.23)Servlet</title>
      <link href="/2022/09/23/%5B2022.11.23%5DServlet/"/>
      <url>/2022/09/23/%5B2022.11.23%5DServlet/</url>
      
        <content type="html"><![CDATA[<h2 id="1、面试题"><a href="#1、面试题" class="headerlink" title="1、面试题"></a>1、面试题</h2><p>请你谈谈一个网站是如何进行访问的</p><p>1、输入一个域名</p><p>2、检查本机的hosts下有没有这个域名的映射；</p><ul><li><p>1、有、返回对应的IP地址</p></li><li><p>2、没有、去DNS（全世界的域名都在这里管理）服务器找，找不到就返回找不到</p></li></ul><h2 id="2、一个web网站"><a href="#2、一个web网站" class="headerlink" title="2、一个web网站"></a>2、一个web网站</h2><p>  将自己写的网站，放到服务器（Tomcat）中指定的web应用的文件夹（webapps）下，就可以访问了</p><p>  网站应该有的结构</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--webapps:Tomcat服务器的web目录</span><br><span class="line">    --ROOT</span><br><span class="line">    -kuangstudy：网站的目录名</span><br><span class="line">    -WEB-INF</span><br><span class="line">    -classes：java程序</span><br><span class="line">    -lib：web应用所依赖的jar包</span><br><span class="line">    -web.xml：网站配置文件</span><br><span class="line">    -index.html：默认的首页</span><br><span class="line">    -<span class="keyword">static</span></span><br><span class="line">    -css</span><br><span class="line">    -style.css</span><br><span class="line">    -js</span><br><span class="line">    -img</span><br></pre></td></tr></table></figure><p>  为什么要学习maven</p><p>  1、在javaweb开发中，我们需要使用大量的jar包，我们手动去导入</p><p>  2、如何能够让一个东西自动帮我们导入并配置这个jar包</p><p>  由此maven诞生</p><h2 id="3、maven项目架构管理工具"><a href="#3、maven项目架构管理工具" class="headerlink" title="3、maven项目架构管理工具"></a>3、maven项目架构管理工具</h2><p>  我们目前用来就是方便导入jar包</p><p>  maven的核心思想：<strong>约定大于配置</strong></p><p>  有约束，不要去违反</p><p>  Maven会规定好你该如何区编写我们的java代码，必须按照这个规范来</p><h1 id="4、servlet"><a href="#4、servlet" class="headerlink" title="4、servlet"></a><strong>4、servlet</strong></h1><h4 id="4-1、servlet简介"><a href="#4-1、servlet简介" class="headerlink" title="4.1、servlet简介"></a>4.1、servlet简介</h4><ul><li>servlet就是sun公司开发动态web的一门技术</li><li>sun在这些API中体重一个接口叫做：Servlet，如果你想开发一个servlet程序，只需要完成两个小步骤：<ul><li>编写一个类，实现servlet接口</li><li>把开发好的java类部署到web服务器中</li></ul></li></ul><p>  <strong>把实现了servlet接口的Java程序叫做servlet</strong></p><h4 id="4-2、HelloServlet"><a href="#4-2、HelloServlet" class="headerlink" title="4.2、HelloServlet"></a>4.2、HelloServlet</h4><p>Servlet接口在sun公司有两个默认的实现类：HttpServlet、GenericServlet</p><p>1、构建一个普通的maven项目，删掉里面的src目录，以后我们的学习就在这个项目里建立Moudel，这个空的工程就是maven主工程</p><p>2、关于maven父子工程的理解</p><ul><li>父项目中会有</li><li>子项目中会有</li><li>父项目中的java子项目可以直接使用</li></ul><p>3、maven环境的优化</p><ul><li>1、修改web.xml文件为最新的</li><li>2、将maven的结构搭建完整</li></ul><p>4、编写一个servlet</p><ul><li>1、编写一个普通类</li><li>2、实现Servlet接口，这里我们直接继承HttpServlet</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于get或者post只是请求实现的不同方式，可以相互调用，业务逻辑都一样</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">//        ServletInputStream inputStream = req.getInputStream();</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//        ServletOutputStream outputStream = resp.getOutputStream();</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        writer.print(<span class="string">&quot;hello servlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、编写servlet的映射</p><p>为什么需要映射，我们写的是 java 程序，但是需要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要在web服务中注册我们写的servlet，还需要给他一个浏览器能够访问的路径；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.lwq.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Servlet的请求路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>6、配置Tomcat</p><p>配置项目发布的路径</p><p>7、启动测试</p><p>启动问题：tomcat版本太高不符合maven依赖会报500错误，并不是代码问题，需要降低Tomcat版本</p><h4 id="4-3、Servlet原理"><a href="#4-3、Servlet原理" class="headerlink" title="4.3、Servlet原理"></a>4.3、Servlet原理</h4><p>Servlet是由web服务器调用，web服务器在收到浏览器的请求之后，会：</p><p><img src="C:\Users\1\AppData\Roaming\Typora\typora-user-images\image-20221124194112110.png" alt="image-20221124194112110"></p><h4 id="4-4、mapping问题"><a href="#4-4、mapping问题" class="headerlink" title="4.4、mapping问题"></a>4.4、mapping问题</h4><p>1、一个servlet可以指定一个映射路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册Servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.lwq.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Servlet的请求路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、一个servlet可以指定多个映射路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册Servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.lwq.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Servlet的请求路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello2<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello3<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello4<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、一个servlet可以指定通用映射路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册Servlet--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.lwq.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--Servlet的请求路径--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4、指定一些后缀等</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册Servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.lwq.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Servlet的请求路径--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--可以自定义后缀实现请求映射--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--*面前不能加项目的路径映射--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.lwq<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>5、优先级问题</p><p>指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.9.9)进程的并发问题</title>
      <link href="/2022/09/09/%5B2022.11.9%5D%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/09/%5B2022.11.9%5D%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>package thread;</p><p>&#x2F;&#x2F;认识并发问题 火车买票</p><p>public class testdemo3 implements Runnable {<br>    private int ecigarette&#x3D;10;<br>    @Override<br>    public void run(){<br>        while (true){<br>            if (ecigarette&lt;&#x3D;0){<br>                break;<br>            }<br>            System.out.println(Thread.currentThread().getName()+”买走了第”+ecigarette–+”根电子烟”);<br>        }</p><pre><code>&#125;</code></pre><p>&#x2F;&#x2F;Class类getName()方法getName()方法在java.lang包中可用。<br>&#x2F;&#x2F;getName()方法用于返回类的名称，接口，原始类型，无效类型以及由此Class对象表示的数组类。</p><p>&#x2F;&#x2F;currentThread()方法<br>&#x2F;&#x2F;currentThread()方法返回正在被执行的线程的信息。</p><pre><code>public static void main(String[] args) &#123;    testdemo3 th=new testdemo3();    new Thread(th,&quot;顶针&quot;).start();    new Thread(th,&quot;尼古丁真&quot;).start();    new Thread(th,&quot;芙蓉王源&quot;).start();&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 龟兔赛跑</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">package thread;</span><br><span class="line"></span><br><span class="line">public class BuyCigarette implements Runnable&#123;</span><br><span class="line">   @Override</span><br><span class="line">   //计步器</span><br><span class="line">    public void run()&#123;</span><br><span class="line"></span><br><span class="line">       for (int i = 0; i &lt;=100 ; i++) &#123;</span><br><span class="line">           if(Thread.currentThread().getName().equals(&quot;芙蓉王源&quot;))&#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   Thread.sleep(200);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   throw new RuntimeException(e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        boolean flag=over(i);</span><br><span class="line">           System.out.println(Thread.currentThread().getName()+&quot;跑了&quot;+i+&quot;步&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断是否完成</span><br><span class="line">    static String winner;</span><br><span class="line"></span><br><span class="line">  public boolean over(int steps)&#123;</span><br><span class="line">    if(winner!=null)</span><br><span class="line">      return true;</span><br><span class="line">    if (steps&gt;=100)&#123;</span><br><span class="line">        winner=Thread.currentThread().getName();</span><br><span class="line">        System.out.println(winner+&quot;抽到了电子烟&quot;);</span><br><span class="line">        System.exit(1);</span><br><span class="line">    &#125;return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BuyCigarette th=new BuyCigarette();</span><br><span class="line">        new Thread(th,&quot;芙蓉王源&quot;).start();</span><br><span class="line">        new Thread(th,&quot;尼古丁真&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.9.7)线程</title>
      <link href="/2022/09/07/%5B2022.11.7%5D%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/09/07/%5B2022.11.7%5D%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>线程就是独立的执行路径;<br>在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程;<br>main()称之为主线程，为系统的入口，用于执行整个程序;<br>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能认为的干预的。<br>对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制;<br>线程会带来额外的开销，如cpu调度时间，并发控制开销。<br>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致</p><h2 id=""><a href="#" class="headerlink" title=" #"></a> <a href="#">#</a></h2><h2 id="线程的创建有两种方式："><a href="#线程的创建有两种方式：" class="headerlink" title="线程的创建有两种方式：#"></a>线程的创建有两种方式：<a href="#">#</a></h2><p>方式一:继承Thread类，重写run()方法,调用start开启线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testdemo1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//run方法线程体</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">//main线程是主线程</span></span><br><span class="line">        <span class="comment">//创建一个线程对象</span></span><br><span class="line">        testdemo1 demo1=<span class="keyword">new</span> <span class="title class_">testdemo1</span>();</span><br><span class="line">        <span class="comment">//调用start()方法开启线程</span></span><br><span class="line">        demo1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里线程的执行顺序并不是按照我们 执行start()的顺序，因为start()方法，并不是代表立即去执行线程，只不过是告诉cpu我可以被调度，至于它先执行哪个线程，要靠cpu去决定。（但是我们可以设置一个优先级，优先级高的显被执行的概率大，但是不是绝对的）</p><p>继承Thread类<br>子类继承Thread类具备多线程能力<br>启动线程:子类对象. start()<br>不建议使用:避免OOP单继承局限性</p><p>方式二:实现Runable接口，重写Run方法，执行线程需要丢入runnable接口实现类，调用start方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testdemo2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//run方法线程体</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建runnbale接口的实现类对象</span></span><br><span class="line">     </span><br><span class="line">        testdemo2 demo2=<span class="keyword">new</span> <span class="title class_">testdemo2</span>();</span><br><span class="line">        Thread th=<span class="keyword">new</span> <span class="title class_">Thread</span>(demo2);</span><br><span class="line">        th.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Thread的构造方法传入Runnable接口的实现类，然后执行start()方法，开启线程，相对于第一种方式，这里的Thread其实就是个静态代理对象。</p><p>实现Runnable接口<br>实现接口Runnable具有多线程能力<br>启动线程:传入目标对象+Thread对象.start()<br>推荐使用:避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.9.2)collection</title>
      <link href="/2022/09/02/%5B2022.11.2%5Dcollection/"/>
      <url>/2022/09/02/%5B2022.11.2%5Dcollection/</url>
      
        <content type="html"><![CDATA[<h1 id="collection接口"><a href="#collection接口" class="headerlink" title="collection接口"></a>collection接口</h1><h3 id="Java标准库自带的java-util包提供了集合类：Collection，它是除Map外所有其他集合类的根接口。Java的java-util包主要提供了以下三种类型的集合："><a href="#Java标准库自带的java-util包提供了集合类：Collection，它是除Map外所有其他集合类的根接口。Java的java-util包主要提供了以下三种类型的集合：" class="headerlink" title="Java标准库自带的java.util包提供了集合类：Collection，它是除Map外所有其他集合类的根接口。Java的java.util包主要提供了以下三种类型的集合：#"></a>Java标准库自带的<code>java.util</code>包提供了集合类：<code>Collection</code>，它是除<code>Map</code>外所有其他集合类的根接口。Java的<code>java.util</code>包主要提供了以下三种类型的集合：<a href="#">#</a></h3><ul><li><code>List</code>：一种<strong>有序列表</strong>的集合，例如，按索引排列的<code>Student</code>的<code>List</code>；</li><li><code>Set</code>：一种<strong>保证没有重复元素</strong>的集合，例如，所有无重复名称的<code>Student</code>的<code>Set</code>；</li><li><code>Map</code>：一种<strong>通过键值（key-value）查找的映射表</strong>集合，例如，根据<code>Student</code>的<code>name</code>查找对应<code>Student</code>的<code>Map</code>。</li></ul><p>1.单列集合框架结构<br>l—-collection接口:单列集合，用来存储一个一个的对象<br>　　　　&#x2F;—-List接口:存储序的、可重复的数据。–&gt;“动态”数组<br>　　　　　　&#x2F;—-Arraylist、LinkedList、vector</p><p>　　　　&#x2F;—-Set接口:存储无序的、不可重复的数据–&gt;高中讲的*集合”<br>　　　　　　&#x2F;—-HashSet、LinkedHashset、TreeSet</p><p>对应图示:</p><p><a href="https://img2022.cnblogs.com/blog/3002690/202210/3002690-20221031212924309-85634725.png"><img src="https://img2022.cnblogs.com/blog/3002690/202210/3002690-20221031212924309-85634725.png"></a></p><p><a href="#" title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/\*</span><br><span class="line">collection接口中声明的方法的测试</span><br><span class="line">向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals().</span><br><span class="line"></span><br><span class="line"> \*/</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">collectiontst</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        Collection coll\=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="number">114</span>);</span><br><span class="line">        coll.add(<span class="number">514</span>);</span><br><span class="line">        coll.add(<span class="literal">true</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">15</span>, <span class="string">&quot;mike&quot;</span>));</span><br><span class="line">        <span class="type">boolean</span> conntuon=coll.contains(<span class="number">114</span>);</span><br><span class="line">        System.out.println(conntuon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#" title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif"></a></p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.8.31)常用类— 6、JDK8的日期类 7、Math类和Random类 8、枚举类与注解</title>
      <link href="/2022/08/31/%5B2022.10.31%5D%E5%B8%B8%E7%94%A8%E7%B1%BB%E2%80%94%206%E3%80%81JDK8%E7%9A%84%E6%97%A5%E6%9C%9F%E7%B1%BB%207%E3%80%81Math%E7%B1%BB%E5%92%8CRandom%E7%B1%BB%208%E3%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/08/31/%5B2022.10.31%5D%E5%B8%B8%E7%94%A8%E7%B1%BB%E2%80%94%206%E3%80%81JDK8%E7%9A%84%E6%97%A5%E6%9C%9F%E7%B1%BB%207%E3%80%81Math%E7%B1%BB%E5%92%8CRandom%E7%B1%BB%208%E3%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=484&vd_source=78421119a4563a7415c84dd650833d12">482.尚硅谷_常用类-JDK8中日期时间API的介绍_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.8.31)集合</title>
      <link href="/2022/08/31/%5B2022.10.31%5D%E9%9B%86%E5%90%88/"/>
      <url>/2022/08/31/%5B2022.10.31%5D%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="数组与集合"><a href="#数组与集合" class="headerlink" title="数组与集合"></a>数组与集合</h1><h4 id="Java的集合类定义在java-util包中，支持泛型，主要提供了3种集合类，包括List，Set和Map。Java集合使用统一的Iterator遍历，尽量不要使用遗留接口。"><a href="#Java的集合类定义在java-util包中，支持泛型，主要提供了3种集合类，包括List，Set和Map。Java集合使用统一的Iterator遍历，尽量不要使用遗留接口。" class="headerlink" title="Java的集合类定义在java.util包中，支持泛型，主要提供了3种集合类，包括List，Set和Map。Java集合使用统一的Iterator遍历，尽量不要使用遗留接口。#"></a>Java的集合类定义在<code>java.util</code>包中，支持泛型，主要提供了3种集合类，包括<code>List</code>，<code>Set</code>和<code>Map</code>。Java集合使用统一的<code>Iterator</code>遍历，尽量不要使用遗留接口。<a href="#">#</a></h4><p>1．集合与数组存储数据概述:<br>集合、数组都是对多个数据进行存储操作的结构，简称Java容器。<br>说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中)<br>2．数组存储的特点：<br>&gt;一旦初始化以后，其长度就确定了。<br>&gt;数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。*<br>比如: String[]arr;int[ ]arr1;object[] arr2;<br>3．数组存储的弊端:<br>&gt;—旦初始化以后,其长度就不可修改。<br>&gt;数组中提供的方法非常限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。<br>&gt;获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用<br>&gt;数组存储数据的特点:有序、可重复。对于无序、不可重复的需求，不能满足。</p><p>4．集合存储的优点:<br>解决数组存储数据方面的弊端</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.8.30)常用类3—StringBuffer与StringBuilder</title>
      <link href="/2022/08/30/%5B2022.10.30%5D%E5%B8%B8%E7%94%A8%E7%B1%BB3%E2%80%94StringBuffer%E4%B8%8EStringBuilder/"/>
      <url>/2022/08/30/%5B2022.10.30%5D%E5%B8%B8%E7%94%A8%E7%B1%BB3%E2%80%94StringBuffer%E4%B8%8EStringBuilder/</url>
      
        <content type="html"><![CDATA[<h3 id="String-StringBuffer与StringBuilder的异同"><a href="#String-StringBuffer与StringBuilder的异同" class="headerlink" title="String,StringBuffer与StringBuilder的异同#"></a>String,StringBuffer与StringBuilder的异同<a href="#">#</a></h3><p>相同之处：<strong>底层都是char[]存储</strong></p><p>不同之处：</p><p>String：从jdk1.0就有，安全的，不可变的字符序列</p><p>StringBuffer：从jdk1.0就有，可变的字符序列，线程安全，效率低</p><p>StringBuilder：jdk5.0才加入，可变的字符序列，线程不安全，效率高</p><p>效率比较：string&lt;stringbuffer&lt;stringbuilder</p><h3 id="StringBuffer类可以创建可修改的字符串序列。该类有StringBuffer-StringBuffer-int-size-StringBuffer-String-s-三个改造方法。"><a href="#StringBuffer类可以创建可修改的字符串序列。该类有StringBuffer-StringBuffer-int-size-StringBuffer-String-s-三个改造方法。" class="headerlink" title="StringBuffer类可以创建可修改的字符串序列。该类有StringBuffer(),StringBuffer(int size),StringBuffer(String s)三个改造方法。#"></a>StringBuffer类可以创建可修改的字符串序列。该类有StringBuffer(),StringBuffer(int size),StringBuffer(String s)三个改造方法。<a href="#">#</a></h3><p>1.StringBuffer()的<strong>初始容量可以容纳16个字符</strong>，当该对象的实体存放的字符的长度大于16时，实体容量就自动增加。StringBuffer对象可以通过length()方法获取实体中存放的字符序列长度，通过capacity()方法来获取当前实体的实际容量。</p><p>2.StringBuffer(int size)可以指定分配给该对象的实体的初始容量参数为参数size指定的字符个数。当该对象的实体存放的字符序列的长度大于size个字符时，实体的容量就自动的增加。以便存放所增加的字符。</p><p>3.StringBuffer(String s)可以指定给对象的实体的初始容量为参数字符串s的长度额外再加16个字符。当该对象的实体存放的字符序列长度大于size个字符时，实体的容量自动的增加，以便存放所增加的字符。</p><h3 id="StringBuffer的常用方法"><a href="#StringBuffer的常用方法" class="headerlink" title="StringBuffer的常用方法#"></a>StringBuffer的常用方法<a href="#">#</a></h3><p><a href="http://t.csdn.cn/xJCyJ">https://blog.csdn.net/qq_35868412&#x2F;article&#x2F;details&#x2F;78153185?biz_id&#x3D;102&amp;utm_term&#x3D;Stringbuffer%E6%96%B9%E6%B3%95&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-78153185&amp;spm&#x3D;1018.2118.3001.4187</a></p><h3 id="StringBuilder的常用方法"><a href="#StringBuilder的常用方法" class="headerlink" title="StringBuilder的常用方法#"></a>StringBuilder的常用方法<a href="#">#</a></h3><p><a href="https://blog.csdn.net/qq/32279165/article/details/111040044">https://blog.csdn.net/qq/32279165/article/details/111040044</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.8.30)常用类4—Date与DateFormat</title>
      <link href="/2022/08/30/%5B2022.10.30%5D%E5%B8%B8%E7%94%A8%E7%B1%BB4%E2%80%94Date%E4%B8%8EDateFormat/"/>
      <url>/2022/08/30/%5B2022.10.30%5D%E5%B8%B8%E7%94%A8%E7%B1%BB4%E2%80%94Date%E4%B8%8EDateFormat/</url>
      
        <content type="html"><![CDATA[<h2 id="1-java-lang-System类"><a href="#1-java-lang-System类" class="headerlink" title="1. java.lang.System类#"></a>1. java.lang.System类<a href="#">#</a></h2><p>System类提供的public static long currentTimeqMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。<br>&gt;此方法适于计算时间差。</p><h2 id="2-java-util-Date类"><a href="#2-java-util-Date类" class="headerlink" title="2.java.util.Date类#"></a>2.java.util.Date类<a href="#">#</a></h2><p>表示特定的瞬间，精确到毫秒</p><p>构造器:<br>&gt;Date():使用无参构造器创建的对象可以获取本地当前时间。</p><p>&gt;Date(long date)<br>常用方法<br>getTime():返回自1970年1月1日 00:00:00 GMT以来此Date对象<br>表示的毫秒数。<br>toString():把此 Date 对象转换为以下形式的String:dow mon dd hh:mm:ss zzz yyyy</p><p>其中: dow是一周中的某一天(Sun, Mon，Tue,wed，Thu,Fri,Sat)，zzz是时间标准。<br>其它很多方法都过时了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   1.用system类中的currentTimeMillis()方法</span></span><br><span class="line"><span class="comment">   2.java.util.Date类</span></span><br><span class="line"><span class="comment">           1）两个构造器的使用</span></span><br><span class="line"><span class="comment">               (1)构造器1:Date()</span></span><br><span class="line"><span class="comment">               (2)构造器2:创建指定毫秒数的Date对象</span></span><br><span class="line"><span class="comment">           2）两个方法的使用</span></span><br><span class="line"><span class="comment">               (1)方法一：toString():显示当前的年月日时分秒</span></span><br><span class="line"><span class="comment">               (2)方法二：getTime():获取当前Date对象对应的毫秒数（时间戳）</span></span><br><span class="line"><span class="comment">    3.java.sql.Date数据库专用，对着数据库中的日期类型的变量</span></span><br><span class="line"><span class="comment">            1)如何实例化？</span></span><br><span class="line"><span class="comment">            java.sq1.Date date3 = new java.sq1.Date(3523532534L);</span></span><br><span class="line"><span class="comment">            System.out.print1n(date3);</span></span><br><span class="line"><span class="comment">            2)如何将util.Date对象转化为sql.Date</span></span><br><span class="line"><span class="comment">                    情况一:</span></span><br><span class="line"><span class="comment">                    Date date4 = new java.sqL.Date(2343243242323L);</span></span><br><span class="line"><span class="comment">                    java.sqL.Date date5 = (java.sqL.Date) date4;</span></span><br><span class="line"><span class="comment">                    情况二:</span></span><br><span class="line"><span class="comment">                    Date date6 = new Date();</span></span><br><span class="line"><span class="comment">                    java.sq1.Date date7 = new java.sq1.Date(date6.getTime());</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">datatimetest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> time=System.currentTimeMillis();</span><br><span class="line">    System.out.println(time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    Date date1=<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    System.out.println(date1);</span><br><span class="line">    System.out.println(date1.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-java-text-SimpleDateFormat类"><a href="#3-java-text-SimpleDateFormat类" class="headerlink" title="3.java.text.SimpleDateFormat类#"></a>3.java.text.SimpleDateFormat类<a href="#">#</a></h2><p>Date类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类。<br>它允许进行<strong>格式化:日期→文本、解析:文本→日期</strong><br><strong><em>格式化:</em></strong><br>SimpleDateFormat() :默认的模式和语言环境创建对象<br>public SimpleDateFormat(String pattern):该构造方法可以用<strong>参数pattern</strong>指定的格式创建一个对象，该对象调用:<br>public String format(Date date):方法格式化时间对象date</p><p><strong><em>解析:</em></strong><br>public Date parse(String source):从给定字符串的开始解析文本，以生成一个日期。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class simpedate &#123;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testSimpleDateFormat() throws ParseException &#123;</span><br><span class="line">    //实例化SimpleDateFormat()</span><br><span class="line">    SimpleDateFormat sdf=new SimpleDateFormat();</span><br><span class="line">    //格式化：日期---&gt;字符串</span><br><span class="line">    Date date=new Date();</span><br><span class="line">    //System.out.println(date);</span><br><span class="line">    String format=sdf.format(date);</span><br><span class="line">    System.out.println(format);</span><br><span class="line">    //解析：格式化的逆过程 字符串---&gt;日期</span><br><span class="line">    String str= &quot;2022/10/30 下午6:58&quot;;</span><br><span class="line">    Date date1 = sdf.parse(str);</span><br><span class="line">    System.out.println(date1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.8.30)常用类5—Calender类</title>
      <link href="/2022/08/30/%5B2022.10.30%5D%E5%B8%B8%E7%94%A8%E7%B1%BB5%E2%80%94Calender%E7%B1%BB/"/>
      <url>/2022/08/30/%5B2022.10.30%5D%E5%B8%B8%E7%94%A8%E7%B1%BB5%E2%80%94Calender%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。"><a href="#Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。" class="headerlink" title="Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。#"></a>Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。<a href="#">#</a></h2><p>获取Calendar实例的方法<br>使用<strong>Calendar.getInstance()<strong>方法<br>调用它的子类</strong>GregorianCalendar</strong>的构造器。  </p><p>一个Calendar的实例是系统时间的抽象表示，通过**get(int field)**方法来取得想要的时间信息。</p><p>比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND<br>public void set(int field,int value)</p><p>public void add(int field, int amount)</p><p>public final Date getTime()<br>public final void setTime(Date date)</p><p>注意:<br>获取月份时:一月是0，二月是1，以此类推，12月是11<br>获取星期时:周日是1，周二是2，。。。。周六是7</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">calendartest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.实例化</span></span><br><span class="line">        <span class="comment">//方式一：创建其子类GregorianCalender的对象</span></span><br><span class="line">        <span class="comment">//方式二：调用其静态方法getInstance()</span></span><br><span class="line"></span><br><span class="line">        Calendar calendar=Calendar.getInstance();</span><br><span class="line">        System.out.println(calendar);</span><br><span class="line">        <span class="comment">//2.常用方法</span></span><br><span class="line">        <span class="comment">//get()</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days);</span><br><span class="line">        <span class="comment">//set();</span></span><br><span class="line">        calendar.set(Calendar.DAY_OF_MONTH, <span class="number">11</span>);</span><br><span class="line">        days=calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days);</span><br><span class="line">        <span class="comment">//add()</span></span><br><span class="line">        calendar.add(Calendar.DAY_OF_MONTH,<span class="number">11</span>);</span><br><span class="line">        days=calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days);</span><br><span class="line">        <span class="comment">//getTime( ):日历类---&gt; Date</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        <span class="comment">// setTime( ):Date ---&gt;日历类</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        calendar.setTime(date1);</span><br><span class="line">        days=calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days);</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.8.29)常用类2—基本数据类型和包装类</title>
      <link href="/2022/08/29/%5B2022.10.29%5D%E5%B8%B8%E7%94%A8%E7%B1%BB2%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
      <url>/2022/08/29/%5B2022.10.29%5D%E5%B8%B8%E7%94%A8%E7%B1%BB2%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>Java提供了八种基本数据类型：byte、short、int、long、float、double、<a href="https://so.csdn.net/so/search?q=boolean&spm=1001.2101.3001.7020">boolean</a>、char，每种基本类型都有其对应的类</p><p>基本数据类型</p><p>对应包装类</p><p><img src="C:\Users\1\AppData\Roaming\Typora\typora-user-images\image-20221123141421951.png" alt="image-20221123141421951"></p><p>可以看到两者命名的区别：基本数据类型首字母都是小写，而对应的包装类首字母都是大写（Java命名习惯，类名首字母需要大写），并且采用全称（缩写int变成了全称Integer）。</p><p>以上8种类都是immutable的，和String类一样，意味着实例一旦创建完成后，就不能改变其成员变量值。</p><h3 id="包装类与基本数据类型的区别"><a href="#包装类与基本数据类型的区别" class="headerlink" title="包装类与基本数据类型的区别#"></a>包装类与基本数据类型的区别<a href="#">#</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）包装类是对象，而基本数据类型不是。</span><br><span class="line"></span><br><span class="line">包装类的引用存放在栈中，实例存放在堆中；而基本数据类型直接存放在栈中。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）包装类需要先初始化再赋值，而基本数据类型可以直接赋值。</span><br><span class="line"></span><br><span class="line"><span class="comment">//包装类与基本数据类型的初始化举例</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">114514</span>);<span class="comment">//需要先用new初始化</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">114514</span>;<span class="comment">//可以直接赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//String的初始化有两种方法，举例</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.8.25)常用类1—String</title>
      <link href="/2022/08/25/%5B2022.10.25%5D%E5%B8%B8%E7%94%A8%E7%B1%BB1%E2%80%94String/"/>
      <url>/2022/08/25/%5B2022.10.25%5D%E5%B8%B8%E7%94%A8%E7%B1%BB1%E2%80%94String/</url>
      
        <content type="html"><![CDATA[<h3 id="string-字符串，使用一对”-“引起来表示。"><a href="#string-字符串，使用一对”-“引起来表示。" class="headerlink" title="string:字符串，使用一对” “引起来表示。#"></a>string:字符串，使用一对” “引起来表示。<a href="#">#</a></h3><p>1.String声明为final的，不可被继承<br>2.String实现了Serializable接口:表示字符串是支持序列化的。<br>实现了Comparable接口:表示String可以比较大小<br>3.String内部定义了final char[ ] value用于存储字符串数据<br>4.通过字面量的方式(区别于new给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p><p>5.字符串常量池中是不会存储相同内容的字符串的。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>String与基本数据类型、包装类之间的转换。<a href="#">#</a></p><p>String –&gt;基本数据类型、包装类:调用包装类的静态方法: parseXxx(str)基本数据类型、包装类–&gt; string:调用string重载的vaLueof( xxx)</p><h3 id="string-与char-之间的转换"><a href="#string-与char-之间的转换" class="headerlink" title="string 与char[]之间的转换#"></a>string 与char[]之间的转换<a href="#">#</a></h3><p>String –&gt; char[]:调用string的toCharArray( )<br>char[] –&gt; string:调用string的构造器</p><h3 id="string-与byte-之间的转换"><a href="#string-与byte-之间的转换" class="headerlink" title="string 与byte[]之间的转换#"></a>string 与byte[]之间的转换<a href="#">#</a></h3><p>String –&gt; byte[]:调用string 的getBytes( )<br>&#x2F;&#x2F;为UTF8编码<br>String str &#x3D; “hello java”;<br>byte[] bytes&#x3D;str.getBytes(“UTF8”);<br>byte[]–&gt; string<br>String srt2&#x3D;new String(bytes,”UTF-8”);</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.8.23)String的不可变性</title>
      <link href="/2022/08/23/%5B2022.10.23%5DString%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7/"/>
      <url>/2022/08/23/%5B2022.10.23%5DString%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="final关键字代表最终、不可改变的"><a href="#final关键字代表最终、不可改变的" class="headerlink" title="final关键字代表最终、不可改变的#"></a>final关键字代表最终、不可改变的<a href="#">#</a></h3><p>常见四种用法：</p><p>1. 可以用来修饰一个类（不能有任何子类）</p><p>2. 可以用来修饰一个方法（最终方法，不能被覆盖重写）</p><p>3. 还可以用来修饰一个局部变量</p><p>（对于基本类型来说，不可变说的是变量当中的数据不可改变</p><p>对于引用类型来说，不可变说的是变量当中的地址值不可改变）</p><p>4. 还可以用来修饰一个成员变量</p><p>成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值。</p><p>对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。</p><p>string是一个final类，代表不可变的字符序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string类的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">stringtest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        String s1=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String s2=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        s1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">​    System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">​    System.out.println(s2);<span class="comment">//hello</span></span><br><span class="line"></span><br><span class="line">​    System.out.println(<span class="string">&quot;*****************&quot;</span>);</span><br><span class="line"></span><br><span class="line">​    String s3=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">​    s3+=<span class="string">&quot;def&quot;</span>;</span><br><span class="line">​    System.out.println(s3);<span class="comment">//abcdef</span></span><br><span class="line">​    System.out.println(s2);</span><br><span class="line">​    System.out.println(<span class="string">&quot;*****************&quot;</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(<a href="https://img2022.cnblogs.com/blog/3002690/202210/3002690-20221023214934230-640401228.png">https://img2022.cnblogs.com/blog/3002690/202210/3002690-20221023214934230-640401228.png</a>)</p><p>(<a href="https://img2022.cnblogs.com/blog/3002690/202210/3002690-20221023214947576-549850338.png">https://img2022.cnblogs.com/blog/3002690/202210/3002690-20221023214947576-549850338.png</a>)</p><p>暂时代替</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.8.11)Java的变量</title>
      <link href="/2022/08/20/%5B2022.10.11%5DJava%E7%9A%84%E5%8F%98%E9%87%8F/"/>
      <url>/2022/08/20/%5B2022.10.11%5DJava%E7%9A%84%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f=<span class="number">0.1f</span>;</span><br><span class="line"><span class="type">double</span> d=<span class="number">1.0</span>/<span class="number">10</span>;</span><br><span class="line">f==d <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> d1=<span class="number">12312312313123123123123123f</span>;</span><br><span class="line"><span class="type">float</span> d2=d1+<span class="number">1</span>;</span><br><span class="line">d1==d2 <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>浮点数是有误差的</strong>，尽量避免使用浮点数进行比较，金额应该用BigDecimal来表示</p><p>浮点型在计算机中，先将小数表示为2进制数，再将二进制用科学计数法来表示。</p><p>浮点型的内存结构分为3各部分，正负号，指数，尾数。<br>指数决定浮点型的取值范围，尾数决定浮点型的精度。<br>当数据太大导致计算溢出前可以先强制转化为Long类型，谁大听谁</p><p>Java的变量有三种类型：<strong>类变量，实例变量，局部变量</strong></p><p>类变量有static修饰，独立于方法之外</p><p>实例变量没有static,独立于方法之外</p><p>局部变量在方法之中</p><p><strong>实例变量的使用需要先实例化</strong>(new)</p><p>static可以不需要实例化对象就可以访问类中的属性和方法，所以学java的时候都用static修饰成员变量（？</p><p>局部变量不能使用static</p><p>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。</p><p><strong>字符串连接符</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String\[\] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line">        <span class="comment">//字符串连接+</span></span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+a+b);</span><br><span class="line">        System.out.println(a+b+<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//为什么？输出 30 1020 30</span></span><br><span class="line"><span class="comment">// 如果字符串连接符两侧有一方出现string类型 那么+会把其他的操作数转化为string类型进行连接</span></span><br><span class="line"><span class="comment">// 字符串在前面 那就将右边变为string进行连接，字符串在后面，前面还是照常运算</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.8.20)Java常用类</title>
      <link href="/2022/08/20/%5B2022.10.20%5DJava%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
      <url>/2022/08/20/%5B2022.10.20%5DJava%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="1、包装类"><a href="#1、包装类" class="headerlink" title="1、包装类"></a>1、包装类</h2><h2 id="2、String类"><a href="#2、String类" class="headerlink" title="2、String类"></a>2、String类</h2><h2 id="3、StringBuffer和StringBuilder类"><a href="#3、StringBuffer和StringBuilder类" class="headerlink" title="3、StringBuffer和StringBuilder类"></a>3、StringBuffer和StringBuilder类</h2><h2 id="4、Date类和DateFormat类"><a href="#4、Date类和DateFormat类" class="headerlink" title="4、Date类和DateFormat类"></a>4、Date类和DateFormat类</h2><h2 id="5、Calender类日期类"><a href="#5、Calender类日期类" class="headerlink" title="5、Calender类日期类"></a>5、Calender类日期类</h2><h2 id="6、JDK8的日期类"><a href="#6、JDK8的日期类" class="headerlink" title="6、JDK8的日期类"></a>6、JDK8的日期类</h2><h2 id="7、Math类和Random类"><a href="#7、Math类和Random类" class="headerlink" title="7、Math类和Random类"></a>7、Math类和Random类</h2><h2 id="8、枚举"><a href="#8、枚举" class="headerlink" title="8、枚举"></a>8、枚举</h2>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.8.20)抽象类 异常等</title>
      <link href="/2022/08/20/%5B2022.10.20%5D%E6%8A%BD%E8%B1%A1%E7%B1%BB%20%E5%BC%82%E5%B8%B8%E7%AD%89/"/>
      <url>/2022/08/20/%5B2022.10.20%5D%E6%8A%BD%E8%B1%A1%E7%B1%BB%20%E5%BC%82%E5%B8%B8%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<h3 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h3><ol><li>作为约束</li><li>定义一些方法，用于让不同的人实现</li><li>public abstract</li><li>public static final</li><li>接口不能被实例化，接口中没有构造方法</li><li>implements可以实现多个接口</li><li>必须要重写接口中的放法</li></ol><h3 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h3><p><img src="https://img2022.cnblogs.com/blog/3002690/202210/3002690-20221021163247909-2127714278.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.8.18)封装，继承，多态</title>
      <link href="/2022/08/18/%5B2022.10.18%5D%E5%B0%81%E8%A3%85%EF%BC%8C%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%A4%9A%E6%80%81/"/>
      <url>/2022/08/18/%5B2022.10.18%5D%E5%B0%81%E8%A3%85%EF%BC%8C%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h2 id="封装是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。"><a href="#封装是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。" class="headerlink" title="封装是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。#"></a><strong>封装是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。</strong><a href="#">#</a></h2><p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p><p>要访问该类的代码和数据，必须通过严格的接口控制</p><p><strong>封装的作用：</strong>提高程序的安全性，保护数据 2.隐藏代码的细节 3.统一接口 4.提高维护性</p><p>🥦</p><h2 id="继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。"><a href="#继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。" class="headerlink" title="继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。#"></a><strong>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</strong><a href="#">#</a></h2><p>1.子类拥有父类非 private 的属性、方法。</p><p>2.子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</p><p>3.子类可以用自己的方式实现父类的方法。</p><p>4.Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</p><p>5.提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctrl+h快捷键可以打开idea的继承树</span><br><span class="line"><span class="number">1.</span>Java中 所有的类都默认直接或间接继承object类</span><br><span class="line"><span class="number">2.</span>Java只能单继承 一个子类只能有一个父类</span><br><span class="line"><span class="number">3.</span>私有类不能被继承</span><br></pre></td></tr></table></figure><p>🥦</p><h2 id="多态是同一个行为具有多个不同表现形式或形态的能力。"><a href="#多态是同一个行为具有多个不同表现形式或形态的能力。" class="headerlink" title="多态是同一个行为具有多个不同表现形式或形态的能力。"></a><strong>多态是同一个行为具有多个不同表现形式或形态的能力。</strong></h2><h2 id="多态就是同一个接口，使用不同的实例而执行不同操作"><a href="#多态就是同一个接口，使用不同的实例而执行不同操作" class="headerlink" title="多态就是同一个接口，使用不同的实例而执行不同操作"></a><strong>多态就是同一个接口，使用不同的实例而执行不同操作</strong></h2><p>多态注意事项:<br>1.多态是方法的多态，属性没有多态<br>2.父类和子类，有联系类型转换异常 classCastException<br>3.存在条件:1.继承关系，2.方法需要重写，3.父类引用指向子类对象 Father p &#x3D; new Son( );<br>🥦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">super与this</span><br><span class="line"></span><br><span class="line">super注意点</span><br><span class="line">1.super调用父类的构造方法，必须在构造方法的第一个</span><br><span class="line">2.super必须出现在子类的方法或者构造方法中</span><br><span class="line">3.super和this不能同时调用构造方法</span><br><span class="line"></span><br><span class="line">和this相比</span><br><span class="line"></span><br><span class="line">代表的对象不同：</span><br><span class="line">this：本身调用者这个对象</span><br><span class="line">super:代表父类对象的应用</span><br><span class="line">前提：</span><br><span class="line">this:没有继承也可以使用</span><br><span class="line">super 只能在继承条件才可以使用</span><br><span class="line">构造方法：</span><br><span class="line">this()：本类的构造</span><br><span class="line">super():父类的构造</span><br></pre></td></tr></table></figure><p><strong>🥦</strong></p><h2 id="构造器就是构造方法"><a href="#构造器就是构造方法" class="headerlink" title="构造器就是构造方法#"></a><strong>构造器就是构造方法</strong><a href="#">#</a></h2><p>类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下两个特点:<br>1.必须和类的名字相同<br>2.必须没有返回类型,也不能写void</p><p>构造器：<br>1.和类名相同<br>2.没有返回值<br>作用：<br>1.new 本质是在调用构造方法<br>2.初始化对象的值<br>注意点：<br>1.定义有参构造后，如果想使用无参构造，显式的定义一个无参的构造</p><p>alt+insert快捷键生成构造器（idea）</p><p>构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">constructor01</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参构造。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是无参构造！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> pAge)</span>&#123;</span><br><span class="line">    age=pAge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String pname,<span class="type">int</span> pAge)</span>&#123;</span><br><span class="line">    name =pname;</span><br><span class="line">    age=pAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造器最大的用处就是在创建对象时执行初始化，当创建一个对象时，系统会为这个对象的实例进行默认的初始化。如果想改变这种默认的初始化，就可以通过自定义构造器来实现。</p><p>构造器可以提供许多特殊的方法，构造器作为一种方法，负责类中成员变量（域）的初始化。</p><p>🥦</p><h2 id="重写：需要有继承关系，子类重写父类的方法"><a href="#重写：需要有继承关系，子类重写父类的方法" class="headerlink" title="重写：需要有继承关系，子类重写父类的方法#"></a><strong>重写：需要有继承关系，子类重写父类的方法</strong><a href="#">#</a></h2><p>重写也称覆盖<br>1.方法名必须相同<br>2.参数列表必须相同<br>3.修饰符：范围可以扩大但不能缩小 public&gt;protected&gt;default&gt;private<br>4.抛出的异常：范围可以被缩小，但不能扩大：ClassNotFoundException–&gt;Exception()<br>重写 子类的方法和父类必须要一致，方法体不同<br>为什么需要重写：<br>父类的功能，子类不一定需要，或者不一定满足</p><p>重写与重载：<a href="https://www.runoob.com/java/java-override-overload.html">https://www.runoob.com/java/java-override-overload.html</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.8.17)数组的一点补充</title>
      <link href="/2022/08/17/%5B2022.10.17%5D%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E7%82%B9%E8%A1%A5%E5%85%85/"/>
      <url>/2022/08/17/%5B2022.10.17%5D%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E7%82%B9%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<p><strong>Arrays.toString( )</strong></p><p>作用：方便地输出数组。<br>这个方法是是用来将数组转换成String类型输出的，入参可以是long，float，double，int，boolean，byte，object<br>型的数组。</p><p>如果使用i.toString()则是输出地址值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.phantomcarrot.array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">maopao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        i=scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            num[j]=scanner.nextInt();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">​    System.out.println(Arrays.toString(mao(num)));<span class="comment">//toString()的使用</span></span><br><span class="line">​    scanner.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] mao(<span class="type">int</span>[] arrays) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrays.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arrays.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrays[j] &gt; arrays[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arrays[j];</span><br><span class="line">                arrays[j] = arrays[j + <span class="number">1</span>];</span><br><span class="line">                arrays[j + <span class="number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="keyword">return</span> arrays;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单的动态输入数组冒泡排序算法</span></span><br></pre></td></tr></table></figure><p><strong>for-each循环（增强型for循环）</strong></p><p>增强的for循环是在传统的for循环中增加的强大的迭代功能的循环，是在jdk1.5之后提出来的，主要是为了提高程序员的开发工作效率。</p><p>&#x2F;*格式：<br>for(元素类型 ele : 数组名&#x2F;Iterable 实例){</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#125;*/</span><br><span class="line"></span><br><span class="line"><span class="comment">//foreach遍历数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foreach01</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">          <span class="comment">//创建一个String数组</span></span><br><span class="line">                String[] line=<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;1111&quot;</span>,<span class="string">&quot;22222&quot;</span>,<span class="string">&quot;33333&quot;</span>&#125;;</span><br><span class="line">                <span class="keyword">for</span>(String string:line)&#123;<span class="comment">//遍历</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;string=&quot;</span>+string);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>稀疏数组</strong></p><p>1.当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p><p>2.稀疏数组的处理方法： ①记录数组一共有几行几列，有多少个不同的值 ②把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.8.17)面向对象之类与对象</title>
      <link href="/2022/08/17/%5B2022.10.17%5D%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/08/17/%5B2022.10.17%5D%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p><strong>面向对象编程的本质就是：以类的方式组织代码，以对象的组织（封装）技术</strong></p><p><strong>方法有两种调用方式</strong></p><p>1.通过创建主函数的对象来调用方法<br>2.通过把 “static” 修饰符把方法可以直接调用函数</p><p><strong>类里面只能有属性和方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Study</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;学习中&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类里面只能有属性和方法</span></span><br></pre></td></tr></table></figure><p><strong>类与对象小结</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.类与对象</span><br><span class="line">    类是一个模板：抽象，对象是一个具体的实例</span><br><span class="line">2.方法</span><br><span class="line">    定义和调用</span><br><span class="line">3.对象的引用</span><br><span class="line">    引用类型：八大基本类型 整型的（byte、short、int、long；字符型的char；浮点型的float、double；布尔型的boolean）</span><br><span class="line">    对象是通过引用来操作的：栈---&gt;堆</span><br><span class="line">对象是通过</span><br><span class="line">4.属性：字段（field） （成员变量）</span><br><span class="line">    默认初始化：</span><br><span class="line">    数字0 0.0</span><br><span class="line">    char:u000</span><br><span class="line">    boolean:false</span><br><span class="line">引用：null</span><br><span class="line">5.对象的创建和使用</span><br><span class="line">    1）必须使用new关键字创造对象，构造器 Person per=new Person</span><br><span class="line">    2)对象的属性 per.name</span><br><span class="line">    3)对象的方法 per.sleep()</span><br><span class="line">6.类：</span><br><span class="line">    静态的属性 （属性）</span><br><span class="line">    动态的行为 （方法）</span><br><span class="line"></span><br><span class="line">[![](https://img2022.cnblogs.com/blog/3002690/202210/3002690-20221018172029662-921543149.gif)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.8.16)数组的初始化</title>
      <link href="/2022/08/16/%5B2022.10.16%5D%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2022/08/16/%5B2022.10.16%5D%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>&#x2F;&#x2F;变量的类型 变量的名字 &#x3D; 变量的值<br>数组的三种初始化<br>数组的初始化方式总共有三种方式：静态初始化，动态初始化，默认初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java中的数组有三种初始化的方式：静态，动态，默认</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态初始化数组</span></span><br><span class="line">        <span class="type">int</span>[] num1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态初始化&quot;</span>);</span><br><span class="line">        <span class="comment">//动态初始化数组 动态初始化数组也有两种方法</span></span><br><span class="line">     </span><br><span class="line">        <span class="comment">//动态初始化数组方法一</span></span><br><span class="line">     </span><br><span class="line">        <span class="type">int</span>[] num2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num2.length; i++) &#123;</span><br><span class="line">            num2[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;动态初始化一&quot;</span>);</span><br><span class="line">        <span class="comment">//动态初始化数组方法二</span></span><br><span class="line">        <span class="type">int</span>[] num3 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        num3[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        num3[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        num3[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        num3[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;动态初始化二&quot;</span>);</span><br><span class="line">     </span><br><span class="line">        <span class="comment">//默认初始化数组</span></span><br><span class="line">        <span class="type">int</span>[] num4 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;默认初始化&quot;</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。</p><p>数组是相同数据类型(数据类型可以为任意类型)的有序集合<br>数组也是对象。数组元素相当于对象的成员变量<br>数组长度的确定的，不可变的。如果越界，则报:ArrayIndexOutofBounds</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.8.15)值传递 重载</title>
      <link href="/2022/08/15/%5B2022.10.15%5D%E5%80%BC%E4%BC%A0%E9%80%92%20%E9%87%8D%E8%BD%BD/"/>
      <url>/2022/08/15/%5B2022.10.15%5D%E5%80%BC%E4%BC%A0%E9%80%92%20%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p><strong>什么是值传递 什么是引用传递 为什么java是值传递</strong></p><p><a href="http://t.csdn.cn/yS3Lj">http://t.csdn.cn/yS3Lj</a> 记住就行</p><p>调用方法:对象名.方法名(实参列表)<br>Java支持两种调用方法的方式，根据方法是否返回值来选择。当方法返回一个值的时候，方法调用通常被当做一个值。例如:<br>int larger &#x3D; max(30，40);<br>如果方法返回值是void，方法调用一定是一条语句。<br>system.out.println( “Hello “);  </p><p><strong>重载就是在一个类中，有相同的函数名称，但形参不同的函数</strong>。<br>方法的重载的规则:<br>方法名称必须相同。<br>参数列表必须不同(个数不同、或类型不同、参数排列顺序不同等)。方法的返回类型可以相同也可以不相同。<br>仅仅返回类型不同不足以成为方法的重载。<br>实现理论:<br>方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择双应的方法，如果匹配失败，则编译器报错。</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.8.15)命令行传参</title>
      <link href="/2022/08/15/%5B2022.10.15%5D%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BC%A0%E5%8F%82/"/>
      <url>/2022/08/15/%5B2022.10.15%5D%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BC%A0%E5%8F%82/</url>
      
        <content type="html"><![CDATA[<p>运行一个程序时候再传递给它消息。这要靠传递命令行参数给main()函数实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DocTest</span> &#123;</span><br><span class="line">    <span class="comment">//命令行传参    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args)</span></span><br><span class="line">      &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length ; i++) &#123;                   system.out.println( <span class="string">&quot;args[ &quot;</span>+i+<span class="string">&quot;]&quot;</span>+args[i]);</span><br><span class="line">            &#125;    </span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到命令窗口以后，首先需要编译该文件，javac + 文件名.java，将会生成.class文件，再返回到src下面，然后执行该程序，格式为：java + 文件路径 + 文件名+需要传进的参数</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.8.14)Java方法</title>
      <link href="/2022/08/14/%5B2022.10.14%5DJava%E6%96%B9%E6%B3%95/"/>
      <url>/2022/08/14/%5B2022.10.14%5DJava%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>加上static变成类变量</p><pre><code>Java方法是语句的集合，它们在一起执行一个功能。方法是解决一类问题的步骤的有序组合方法包含于类或对象中方法在程序中被创建，在其他地方被引用</code></pre><p>设计方法的原则:方法的本意是功能块，就是实现某个功能的语句块的集合，我们设计方法的时候，最好保持方法的原子性，就是一个方法只完成一个功能，这样有利于我们后期的扩展</p><h5 id="若不是静态类，在调用的时候要将此方法实例化"><a href="#若不是静态类，在调用的时候要将此方法实例化" class="headerlink" title="若不是静态类，在调用的时候要将此方法实例化"></a>若不是静态类，在调用的时候要将此方法实例化</h5><h5 id="若是静态类，则可以直接调用"><a href="#若是静态类，则可以直接调用" class="headerlink" title="若是静态类，则可以直接调用"></a>若是静态类，则可以直接调用</h5>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.8.14)三角形</title>
      <link href="/2022/08/14/%5B2022.10.14%5D%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
      <url>/2022/08/14/%5B2022.10.14%5D%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<p>待补充</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(2022.8.13)循环与打印</title>
      <link href="/2022/08/13/%5B2022.10.13%5D%E5%BE%AA%E7%8E%AF%E4%B8%8E%E6%89%93%E5%8D%B0/"/>
      <url>/2022/08/13/%5B2022.10.13%5D%E5%BE%AA%E7%8E%AF%E4%B8%8E%E6%89%93%E5%8D%B0/</url>
      
        <content type="html"><![CDATA[<p>for与while，print与println,用scanner获取char的输入</p><p>Java中Scanner本身不支持直接获取char类型的数据</p><p>但是可以<strong>通过charAt()方法截取string的首位</strong>来获取char类型的数据</p><p>charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。<br><strong>该方法返回的数据类型为char类型</strong></p><p>Scanner scanner&#x3D;new Scanner(System.in);<br>char ch &#x3D; scanner.next().charAt(0);</p><p> <strong>print和println的区别</strong></p><p>\n：在Windows中表示换行，换到下一行的行首位置。在Linux，unix中表示左右位置不发生改变，换到下一行，及换行前后的纵坐标相同。</p><p>\t：在Window中表示缩进，相当于按下Tab键之间的距离，一般为八个字符。</p><p>\r：在Window中表示回车，即移动到本行的最开始位置。</p><p>System.out.println();<br> &#x2F;&#x2F;或者System.out.print(“\n”);<br>&#x2F;&#x2F;这两段代码等同，print加\n就是println<br>&#x2F;&#x2F;println输出完会换行，print输出完不会换行</p><p> <a href="https://img2022.cnblogs.com/blog/3002690/202210/3002690-20221013231813448-1832651364.gif"><img src="https://img2022.cnblogs.com/blog/3002690/202210/3002690-20221013231813448-1832651364.gif"></a></p><p><strong>while循环和for循环的区别</strong></p><p>for循环的表达式为：for（单次表达式;条件表达式;末尾循环体）{中间循环体；}。</p><p>while循环的表达式为：while（表达式）{循环体}。</p><p><a href="#" title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String\[\] args)</span> &#123;</span><br><span class="line">     <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span>(i &lt;= <span class="number">1000</span>)&#123;</span><br><span class="line">         <span class="comment">//++i;</span></span><br><span class="line">         <span class="keyword">if</span> (i%<span class="number">5</span>==<span class="number">0</span>)</span><br><span class="line">         System.out.print(i+<span class="string">&quot;\\t&quot;</span>);</span><br><span class="line">         i++;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (i%<span class="number">15</span>==<span class="number">0</span>)&#123;</span><br><span class="line">         System.out.println();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;  </span><br><span class="line">为什么错了 不能按照三个一行输出？  </span><br><span class="line">因为第二个<span class="keyword">if</span>没有被扩进去！！！！</span><br></pre></td></tr></table></figure><p><a href="#" title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif"></a></p><p> 顺便记一下idea中for循环快捷键：数字.fori（需要在main或者自定义方法中才能生效）</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题整理-JavaSE-4</title>
      <link href="/2021/10/20/Java-4/"/>
      <url>/2021/10/20/Java-4/</url>
      
        <content type="html"><![CDATA[<h4 id="1-36-遇到过异常吗，如何处理？"><a href="#1-36-遇到过异常吗，如何处理？" class="headerlink" title="1.36 遇到过异常吗，如何处理？"></a>1.36 遇到过异常吗，如何处理？</h4><p>​<strong>参考答案</strong></p><p>​在Java中，可以按照如下三个步骤处理异常：</p><ol><li><p>​捕获异常 </p><p>​将业务代码包裹在try块内部，当业务代码中发生任何异常时，系统都会为此异常创建一个异常对象。创建异常对象之后，JVM会在try块之后寻找可以处理它的catch块，并将异常对象交给这个catch块处理。 </p></li><li><p>​处理异常 </p><p>​在catch块中处理异常时，应该先记录日志，便于以后追溯这个异常。然后根据异常的类型、结合当前的业务情况，进行相应的处理。比如，给变量赋予一个默认值、直接返回空值、向外抛出一个新的业务异常交给调用者处理，等等。 </p></li><li><p>​回收资源 </p><p>​如果业务代码打开了某个资源，比如数据库连接、网络连接、磁盘文件等，则需要在这段业务代码执行完毕后关闭这项资源。并且，无论是否发生异常，都要尝试关闭这项资源。将关闭资源的代码写在finally块内，可以满足这种需求，即无论是否发生异常，finally块内的代码总会被执行。</p></li></ol><p> </p><h4 id="1-37-说一说Java的异常机制"><a href="#1-37-说一说Java的异常机制" class="headerlink" title="1.37 说一说Java的异常机制"></a>1.37 说一说Java的异常机制</h4><p>​<strong>参考答案</strong></p><p>​关于异常处理：</p><p>​在Java中，处理异常的语句由try、catch、finally三部分组成。其中，try块用于包裹业务代码，catch块用于捕获并处理某个类型的异常，finally块则用于回收资源。当业务代码发生异常时，系统会创建一个异常对象，然后由JVM寻找可以处理这个异常的catch块，并将异常对象交给这个catch块处理。若业务代码打开了某项资源，则可以在finally块中关闭这项资源，因为无论是否发生异常，finally块一定会执行。</p><p>​关于抛出异常：</p><p>​当程序出现错误时，系统会自动抛出异常。除此以外，Java也允许程序主动抛出异常。当业务代码中，判断某项错误的条件成立时，可以使用throw关键字向外抛出异常。在这种情况下，如果当前方法不知道该如何处理这个异常，可以在方法签名上通过throws关键字声明抛出异常，则该异常将交给JVM处理。</p><p>​关于异常跟踪栈：</p><p>​程序运行时，经常会发生一系列方法调用，从而形成方法调用栈。异常机制会导致异常在这些方法之间传播，而异常传播的顺序与方法的调用相反。异常从发生异常的方法向外传播，首先传给该方法的调用者，再传给上层调用者，以此类推。最终会传到main方法，若依然没有得到处理，则JVM会终止程序，并打印异常跟踪栈的信息</p><h4 id="1-38-请介绍Java的异常接口"><a href="#1-38-请介绍Java的异常接口" class="headerlink" title="1.38 请介绍Java的异常接口"></a>1.38 请介绍Java的异常接口</h4><p>​<strong>参考答案</strong></p><p>​Throwable是异常的顶层父类，代表所有的非正常情况。它有两个直接子类，分别是Error、Exception。</p><p>​Error是错误，一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误、动态链接失败等，这种错误无法恢复或不可能捕获，将导致应用程序中断。通常应用程序无法处理这些错误，因此应用程序不应该试图使用catch块来捕获Error对象。在定义方法时，也无须在其throws子句中声明该方法可能抛出Error及其任何子类。</p><p>​Exception是异常，它被分为两大类，分别是Checked异常和Runtime异常。所有的RuntimeException类及其子类的实例被称为Runtime异常；不是RuntimeException类及其子类的异常实例则被称为Checked异常。Java认为Checked异常都是可以被处理（修复）的异常，所以Java程序必须显式处理Checked异常。如果程序没有处理Checked异常，该程序在编译时就会发生错误，无法通过编译。Runtime异常则更加灵活，Runtime异常无须显式声明抛出，如果程序需要捕获Runtime异常，也可以使用try…catch块来实现。</p><h4 id="1-39-finally是无条件执行的吗？"><a href="#1-39-finally是无条件执行的吗？" class="headerlink" title="1.39 finally是无条件执行的吗？"></a>1.39 finally是无条件执行的吗？</h4><p>​<strong>参考答案</strong></p><p>​不管try块中的代码是否出现异常，也不管哪一个catch块被执行，甚至在try块或catch块中执行了return语句，finally块总会被执行。</p><p>​<strong>注意事项</strong></p><p>​如果在try块或catch块中使用 System.exit(1); 来退出虚拟机，则finally块将失去执行的机会。但是我们在实际的开发中，重来都不会这样做，所以尽管存在这种导致finally块无法执行的可能，也只是一种可能而已。</p><h4 id="1-40-在finally中return会发生什么？"><a href="#1-40-在finally中return会发生什么？" class="headerlink" title="1.40 在finally中return会发生什么？"></a>1.40 在finally中return会发生什么？</h4><p>​<strong>参考答案</strong></p><p>​在通常情况下，不要在finally块中使用return、throw等导致方法终止的语句，一旦在finally块中使用了return、throw语句，将会导致try块、catch块中的return、throw语句失效。</p><p>​<strong>详细解析</strong></p><p>​当Java程序执行try块、catch块时遇到了return或throw语句，这两个语句都会导致该方法立即结束，但是系统执行这两个语句并不会结束该方法，而是去寻找该异常处理流程中是否包含finally块，如果没有finally块，程序立即执行return或throw语句，方法终止；如果有finally块，系统立即开始执行finally块。只有当finally块执行完成后，系统才会再次跳回来执行try块、catch块里的return或throw语句；如果finally块里也使用了return或throw等导致方法终止的语句，finally块已经终止了方法，系统将不会跳回去执行try块、catch块里的任何代码。</p><h4 id="1-41-说一说你对static关键字的理解"><a href="#1-41-说一说你对static关键字的理解" class="headerlink" title="1.41 说一说你对static关键字的理解"></a>1.41 说一说你对static关键字的理解</h4><p>​<strong>参考答案</strong></p><p>​在Java类里只能包含成员变量、方法、构造器、初始化块、内部类（包括接口、枚举）5种成员，而static可以修饰成员变量、方法、初始化块、内部类（包括接口、枚举），以static修饰的成员就是类成员。类成员属于整个类，而不属于单个对象。</p><p>​对static关键字而言，有一条非常重要的规则：类成员（包括成员变量、方法、初始化块、内部类和内部枚举）不能访问实例成员（包括成员变量、方法、初始化块、内部类和内部枚举）。因为类成员是属于类的，类成员的作用域比实例成员的作用域更大，完全可能出现类成员已经初始化完成，但实例成员还不曾初始化的情况，如果允许类成员访问实例成员将会引起大量错误。</p><h4 id="1-42-static修饰的类能不能被继承？"><a href="#1-42-static修饰的类能不能被继承？" class="headerlink" title="1.42 static修饰的类能不能被继承？"></a>1.42 static修饰的类能不能被继承？</h4><p>​<strong>参考答案</strong></p><p>​static修饰的类可以被继承。</p><p>​<strong>扩展阅读</strong></p><p>​如果使用static来修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。因此使用static修饰的内部类被称为类内部类，有的地方也称为静态内部类。</p><p>​static关键字的作用是把类的成员变成类相关，而不是实例相关，即static修饰的成员属于整个类，而不属于单个对象。外部类的上一级程序单元是包，所以不可使用static修饰；而内部类的上一级程序单元是外部类，使用static修饰可以将内部类变成外部类相关，而不是外部类实例相关。因此static关键字不可修饰外部类，但可修饰内部类。</p><p>​静态内部类需满足如下规则：</p><ol><li><p>​静态内部类可以包含静态成员，也可以包含非静态成员； </p></li><li><p>​静态内部类不能访问外部类的实例成员，只能访问它的静态成员； </p></li><li><p>​外部类的所有方法、初始化块都能访问其内部定义的静态内部类； </p></li><li><p>​在外部类的外部，也可以实例化静态内部类，语法如下： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类 变量名 = new 外部类.内部类构造方法();</span><br></pre></td></tr></table></figure></li></ol><h4 id="1-43-static和final有什么区别？"><a href="#1-43-static和final有什么区别？" class="headerlink" title="1.43 static和final有什么区别？"></a>1.43 static和final有什么区别？</h4><p>​<strong>参考答案</strong></p><p>​static关键字可以修饰成员变量、成员方法、初始化块、内部类，被static修饰的成员是类的成员，它属于类、不属于单个对象。以下是static修饰这4种成员时表现出的特征：</p><ul><li>​类变量：被static修饰的成员变量叫类变量（静态变量）。类变量属于类，它随类的信息存储在方法区，并不随对象存储在堆中，类变量可以通过类名来访问，也可以通过对象名来访问，但建议通过类名访问它。 </li><li>​类方法：被static修饰的成员方法叫类方法（静态方法）。类方法属于类，可以通过类名访问，也可以通过对象名访问，建议通过类名访问它。 </li><li>​静态块：被static修饰的初始化块叫静态初始化块。静态块属于类，它在类加载的时候被隐式调用一次，之后便不会被调用了。 </li><li>​静态内部类：被static修饰的内部类叫静态内部类。静态内部类可以包含静态成员，也可以包含非静态成员。静态内部类不能访问外部类的实例成员，只能访问外部类的静态成员。外部类的所有方法、初始化块都能访问其内部定义的静态内部类。</li></ul><p> </p><p>​final关键字可以修饰类、方法、变量，以下是final修饰这3种目标时表现出的特征：</p><ul><li>​final类：final关键字修饰的类不可以被继承。 </li><li>​final方法：final关键字修饰的方法不可以被重写。 </li><li>​final变量：final关键字修饰的变量，一旦获得了初始值，就不可以被修改。</li></ul><p> </p><p>​<strong>扩展阅读</strong></p><p>​变量分为成员变量、局部变量。</p><p>​final修饰成员变量：</p><ul><li>​类变量：可以在声明变量时指定初始值，也可以在静态初始化块中指定初始值； </li><li>​实例变量：可以在声明变量时指定初始值，也可以在初始化块或构造方法中指定初始值；</li></ul><p> </p><p>​final修饰局部变量：</p><ul><li>​可以在声明变量时指定初始值，也可以在后面的代码中指定初始值。</li></ul><p> </p><p>​<em>注意：被 final 修饰的任何形式的变量，一旦获得了初始值，就不可以被修改！</em></p><h4 id="1-44-说一说你对泛型的理解"><a href="#1-44-说一说你对泛型的理解" class="headerlink" title="1.44 说一说你对泛型的理解"></a>1.44 说一说你对泛型的理解</h4><p>​<strong>参考答案</strong></p><p>​Java集合有个缺点—把一个对象“丢进”集合里之后，集合就会“忘记”这个对象的数据类型，当再次取出该对象时，该对象的编译类型就变成了Object类型（其运行时类型没变）。</p><p>​Java集合之所以被设计成这样，是因为集合的设计者不知道我们会用集合来保存什么类型的对象，所以他们把集合设计成能保存任何类型的对象，只要求具有很好的通用性。但这样做带来如下两个问题：</p><ul><li>​集合对元素类型没有任何限制，这样可能引发一些问题。例如，想创建一个只能保存Dog对象的集合，但程序也可以轻易地将Cat对象“丢”进去，所以可能引发异常。 </li><li>​由于把对象“丢进”集合时，集合丢失了对象的状态信息，只知道它盛装的是Object，因此取出集合元素后通常还需要进行强制类型转换。这种强制类型转换既增加了编程的复杂度，也可能引发ClassCastException异常。</li></ul><p> </p><p>​从Java 5开始，Java引入了“参数化类型”的概念，允许程序在创建集合时指定集合元素的类型，Java的参数化类型被称为泛型（Generic）。例如 List<String>，表明该List只能保存字符串类型的对象。</p><p>​有了泛型以后，程序再也不能“不小心”地把其他对象“丢进”集合中。而且程序更加简洁，集合自动记住所有集合元素的数据类型，从而无须对集合元素进行强制类型转换。</p><h4 id="1-45-介绍一下泛型擦除"><a href="#1-45-介绍一下泛型擦除" class="headerlink" title="1.45 介绍一下泛型擦除"></a>1.45 介绍一下泛型擦除</h4><p>​<strong>参考答案</strong></p><p>​在严格的泛型代码里，带泛型声明的类总应该带着类型参数。但为了与老的Java代码保持一致，也允许在使用带泛型声明的类时不指定实际的类型。如果没有为这个泛型类指定实际的类型，此时被称作raw type（原始类型），默认是声明该泛型形参时指定的第一个上限类型。</p><p>​当把一个具有泛型信息的对象赋给另一个没有泛型信息的变量时，所有在尖括号之间的类型信息都将被扔掉。比如一个 List<String> 类型被转换为List，则该List对集合元素的类型检查变成了泛型参数的上限（即Object）。</p><p>​上述规则即为泛型擦除，可以通过下面代码进一步理解泛型擦除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = ...; List list2 = list1; // list2将元素当做Object处理</span><br></pre></td></tr></table></figure><p>​<strong>扩展阅读</strong></p><p>​从逻辑上来看，List<String> 是List的子类，如果直接把一个List对象赋给一个List<String>对象应该引起编译错误，但实际上不会。对泛型而言，可以直接把一个List对象赋给一个 List<String> 对象，编译器仅仅提示“未经检查的转换”。</p><p>​上述规则叫做泛型转换，可以通过下面代码进一步理解泛型转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list1 = ...; List&lt;String&gt; list2 = list1; // 编译时警告“未经检查的转换”</span><br></pre></td></tr></table></figure><h4 id="1-46-List-lt-super-T-gt-和List-lt-extends-T-gt-有什么区别？"><a href="#1-46-List-lt-super-T-gt-和List-lt-extends-T-gt-有什么区别？" class="headerlink" title="1.46 List&lt;? super T&gt;和List&lt;? extends T&gt;有什么区别？"></a>1.46 List&lt;? super T&gt;和List&lt;? extends T&gt;有什么区别？</h4><p>​<strong>参考答案</strong></p><ul><li>​? 是类型通配符，List&lt;?&gt; 可以表示各种泛型List的父类，意思是元素类型未知的List； </li><li>​List&lt;? super T&gt; 用于设定类型通配符的下限，此处 ? 代表一个未知的类型，但它必须是T的父类型； </li><li>​List&lt;? extends T&gt; 用于设定类型通配符的上限，此处 ? 代表一个未知的类型，但它必须是T的子类型。</li></ul><p> </p><p>​<strong>扩展阅读</strong></p><p>​在Java的早期设计中，允许把Integer[]数组赋值给Number[]变量，此时如果试图把一个Double对象保存到该Number[]数组中，编译可以通过，但在运行时抛出ArrayStoreException异常。这显然是一种不安全的设计，因此Java在泛型设计时进行了改进，它不再允许把 List<Integer> 对象赋值给 List<Number> 变量。</p><p>​数组和泛型有所不同，假设Foo是Bar的一个子类型（子类或者子接口），那么Foo[]依然是Bar[]的子类型，但G<Foo> 不是 G<Bar> 的子类型。Foo[]自动向上转型为Bar[]的方式被称为型变，也就是说，Java的数组支持型变，但Java集合并不支持型变。Java泛型的设计原则是，只要代码在编译时没有出现警告，就不会遇到运行时ClassCastException异常。</p><h4 id="1-47-说一说你对Java反射机制的理解"><a href="#1-47-说一说你对Java反射机制的理解" class="headerlink" title="1.47 说一说你对Java反射机制的理解"></a>1.47 说一说你对Java反射机制的理解</h4><p>​<strong>参考答案</strong></p><p>​Java程序中的对象在运行时可以表现为两种类型，即编译时类型和运行时类型。例如 Person p &#x3D; new Student(); ，这行代码将会生成一个p变量，该变量的编译时类型为Person，运行时类型为Student。</p><p>​有时，程序在运行时接收到外部传入的一个对象，该对象的编译时类型是Object，但程序又需要调用该对象的运行时类型的方法。这就要求程序需要在运行时发现对象和类的真实信息，而解决这个问题有以下两种做法：</p><ul><li>​第一种做法是假设在编译时和运行时都完全知道类型的具体信息，在这种情况下，可以先使用instanceof运算符进行判断，再利用强制类型转换将其转换成其运行时类型的变量即可。 </li><li>​第二种做法是编译时根本无法预知该对象和类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息，这就必须使用反射。</li></ul><p> </p><p>​具体来说，通过反射机制，我们可以实现如下的操作：</p><ul><li>​程序运行时，可以通过反射获得任意一个类的Class对象，并通过这个对象查看这个类的信息； </li><li>​程序运行时，可以通过反射创建任意一个类的实例，并访问该实例的成员； </li><li>​程序运行时，可以通过反射机制生成一个类的动态代理类或动态代理对象。</li></ul><p> </p><h4 id="1-48-Java反射在实际项目中有哪些应用场景？"><a href="#1-48-Java反射在实际项目中有哪些应用场景？" class="headerlink" title="1.48 Java反射在实际项目中有哪些应用场景？"></a>1.48 Java反射在实际项目中有哪些应用场景？</h4><p>​<strong>参考答案</strong></p><p>​Java的反射机制在实际项目中应用广泛，常见的应用场景有：</p><ul><li>​使用JDBC时，如果要创建数据库的连接，则需要先通过反射机制加载数据库的驱动程序； </li><li>​多数框架都支持注解&#x2F;XML配置，从配置中解析出来的类是字符串，需要利用反射机制实例化； </li><li>​面向切面编程（AOP）的实现方案，是在程序运行时创建目标对象的代理类，这必须由反射机制来实现。</li></ul><p> </p><h4 id="1-49-说一说Java的四种引用方式"><a href="#1-49-说一说Java的四种引用方式" class="headerlink" title="1.49 说一说Java的四种引用方式"></a>1.49 说一说Java的四种引用方式</h4><p>​<strong>参考答案</strong></p><p>​Java对象的四种引用方式分别是强引用、软引用、弱引用、虚引用，具体含义如下：</p><ul><li>​强引用：这是Java程序中最常见的引用方式，即程序创建一个对象，并把这个对象赋给一个引用变量，程序通过该引用变量来操作实际的对象。当一个对象被一个或一个以上的引用变量所引用时，它处于可达状态，不可能被系统垃圾回收机制回收。 </li><li>​软引用：当一个对象只有软引用时，它有可能被垃圾回收机制回收。对于只有软引用的对象而言，当系统内存空间足够时，它不会被系统回收，程序也可使用该对象。当系统内存空间不足时，系统可能会回收它。软引用通常用于对内存敏感的程序中。 </li><li>​弱引用：弱引用和软引用很像，但弱引用的引用级别更低。对于只有弱引用的对象而言，当系统垃圾回收机制运行时，不管系统内存是否足够，总会回收该对象所占用的内存。当然，并不是说当一个对象只有弱引用时，它就会立即被回收，正如那些失去引用的对象一样，必须等到系统垃圾回收机制运行时才会被回收。 </li><li>​虚引用：虚引用完全类似于没有引用。虚引用对对象本身没有太大影响，对象甚至感觉不到虚引用的存在。如果一个对象只有一个虚引用时，那么它和没有引用的效果大致相同。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列联合使用。</li></ul><p> </p>]]></content>
      
      
      <categories>
          
          <category> Java面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题整理-JavaSE-3</title>
      <link href="/2021/10/20/Java-3/"/>
      <url>/2021/10/20/Java-3/</url>
      
        <content type="html"><![CDATA[<h4 id="1-21-说一说hashCode-和equals-的关系"><a href="#1-21-说一说hashCode-和equals-的关系" class="headerlink" title="1.21 说一说hashCode()和equals()的关系"></a>1.21 说一说hashCode()和equals()的关系</h4><p>​<strong>参考答案</strong></p><p>​hashCode()用于获取哈希码（散列码），eauqls()用于比较两个对象是否相等，它们应遵守如下规定：</p><ul><li>​如果两个对象相等，则它们必须有相同的哈希码。 </li><li>​如果两个对象有相同的哈希码，则它们未必相等。</li></ul><p> </p><p>​<strong>扩展阅读</strong></p><p>​在Java中，Set接口代表无序的、元素不可重复的集合，HashSet则是Set接口的典型实现。</p><p>​当向HashSet中加入一个元素时，它需要判断集合中是否已经包含了这个元素，从而避免重复存储。由于这个判断十分的频繁，所以要讲求效率，绝不能采用遍历集合逐个元素进行比较的方式。实际上，HashSet是通过获取对象的哈希码，以及调用对象的equals()方法来解决这个判断问题的。</p><p>​HashSet首先会调用对象的hashCode()方法获取其哈希码，并通过哈希码确定该对象在集合中存放的位置。假设这个位置之前已经存了一个对象，则HashSet会调用equals()对两个对象进行比较。若相等则说明对象重复，此时不会保存新加的对象。若不等说明对象不重复，但是它们存储的位置发生了碰撞，此时HashSet会采用链式结构在同一位置保存多个对象，即将新加对象链接到原来对象的之后。之后，再有新添加对象也映射到这个位置时，就需要与这个位置中所有的对象进行equals()比较，若均不相等则将其链到最后一个对象之后。</p><h4 id="1-22-为什么要重写hashCode-和equals-？"><a href="#1-22-为什么要重写hashCode-和equals-？" class="headerlink" title="1.22 为什么要重写hashCode()和equals()？"></a>1.22 为什么要重写hashCode()和equals()？</h4><p>​<strong>参考答案</strong></p><p>​Object类提供的equals()方法默认是用&#x3D;&#x3D;来进行比较的，也就是说只有两个对象是同一个对象时，才能返回相等的结果。而实际的业务中，我们通常的需求是，若两个不同的对象它们的内容是相同的，就认为它们相等。鉴于这种情况，Object类中equals()方法的默认实现是没有实用价值的，所以通常都要重写。</p><p>​由于hashCode()与equals()具有联动关系（参考“说一说hashCode()和equals()的关系”一题），所以equals()方法重写时，通常也要将hashCode()进行重写，使得这两个方法始终满足相关的约定。</p><h4 id="1-23-x3D-x3D-和equals-有什么区别？"><a href="#1-23-x3D-x3D-和equals-有什么区别？" class="headerlink" title="1.23 &#x3D;&#x3D;和equals()有什么区别？"></a>1.23 &#x3D;&#x3D;和equals()有什么区别？</h4><p>​<strong>参考答案</strong></p><p>​&#x3D;&#x3D;运算符：</p><ul><li>​作用于基本数据类型时，是比较两个数值是否相等； </li><li>​作用于引用数据类型时，是比较两个对象的内存地址是否相同，即判断它们是否为同一个对象；</li></ul><p> </p><p>​equals()方法：</p><ul><li>​没有重写时，Object默认以 &#x3D;&#x3D; 来实现，即比较两个对象的内存地址是否相同； </li><li>​进行重写后，一般会按照对象的内容来进行比较，若两个对象内容相同则认为对象相等，否则认为对象不等。</li></ul><p> </p><h4 id="1-24-String类有哪些方法？"><a href="#1-24-String类有哪些方法？" class="headerlink" title="1.24 String类有哪些方法？"></a>1.24 String类有哪些方法？</h4><p>​<strong>参考答案</strong></p><p>​String类是Java最常用的API，它包含了大量处理字符串的方法，比较常用的有：</p><ul><li>​char charAt(int index)：返回指定索引处的字符； </li><li>​String substring(int beginIndex, int endIndex)：从此字符串中截取出一部分子字符串； </li><li>​String[] split(String regex)：以指定的规则将此字符串分割成数组； </li><li>​String trim()：删除字符串前导和后置的空格； </li><li>​int indexOf(String str)：返回子串在此字符串首次出现的索引； </li><li>​int lastIndexOf(String str)：返回子串在此字符串最后出现的索引； </li><li>​boolean startsWith(String prefix)：判断此字符串是否以指定的前缀开头； </li><li>​boolean endsWith(String suffix)：判断此字符串是否以指定的后缀结尾； </li><li>​String toUpperCase()：将此字符串中所有的字符大写； </li><li>​String toLowerCase()：将此字符串中所有的字符小写； </li><li>​String replaceFirst(String regex, String replacement)：用指定字符串替换第一个匹配的子串； </li><li>​String replaceAll(String regex, String replacement)：用指定字符串替换所有的匹配的子串。</li></ul><p> </p><p>​<strong>注意事项</strong></p><p>​String类的方法太多了，你没必要都记下来，更不需要一一列举。面试时能说出一些常用的方法，表现出对这个类足够的熟悉就可以了。另外，建议你挑几个方法仔细看看源码实现，面试时可以重点说这几个方法。</p><h4 id="1-25-String可以被继承吗？"><a href="#1-25-String可以被继承吗？" class="headerlink" title="1.25 String可以被继承吗？"></a>1.25 String可以被继承吗？</h4><p>​<strong>参考答案</strong></p><p>​String类由final修饰，所以不能被继承。</p><p>​<strong>扩展阅读</strong></p><p>​在Java中，String类被设计为不可变类，主要表现在它保存字符串的成员变量是final的。</p><ul><li>​Java 9之前字符串采用char[]数组来保存字符，即 private final char[] value； </li><li>​Java 9做了改进，采用byte[]数组来保存字符，即 private final byte[] value；</li></ul><p> </p><p>​之所以要把String类设计为不可变类，主要是出于安全和性能的考虑，可归纳为如下4点。</p><ul><li>​由于字符串无论在任何 Java 系统中都广泛使用，会用来存储敏感信息，如账号，密码，网络路径，文件处理等场景里，保证字符串 String 类的安全性就尤为重要了，如果字符串是可变的，容易被篡改，那我们就无法保证使用字符串进行操作时，它是安全的，很有可能出现 SQL 注入，访问危险文件等操作。 </li><li>​在多线程中，只有不变的对象和值是线程安全的，可以在多个线程中共享数据。由于 String 天然的不可变，当一个线程”修改“了字符串的值，只会产生一个新的字符串对象，不会对其他线程的访问产生副作用，访问的都是同样的字符串数据，不需要任何同步操作。 </li><li>​字符串作为基础的数据结构，大量地应用在一些集合容器之中，尤其是一些散列集合，在散列集合中，存放元素都要根据对象的 hashCode() 方法来确定元素的位置。由于字符串 hashcode 属性不会变更，保证了唯一性，使得类似 HashMap，HashSet 等容器才能实现相应的缓存功能。由于 String 的不可变，避免重复计算 hashcode，只要使用缓存的 hashcode 即可，这样一来大大提高了在散列集合中使用 String 对象的性能。 </li><li>​当字符串不可变时，字符串常量池才有意义。字符串常量池的出现，可以减少创建相同字面量的字符串，让不同的引用指向池中同一个字符串，为运行时节约很多的堆内存。若字符串可变，字符串常量池失去意义，基于常量池的 String.intern() 方法也失效，每次创建新的字符串将在堆内开辟出新的空间，占据更多的内存。</li></ul><p> </p><p>​因为要保证String类的不可变，那么将这个类定义为final的就很容易理解了。如果没有final修饰，那么就会存在String的子类，这些子类可以重写String类的方法，强行改变字符串的值，这便违背了String类设计的初衷。</p><h4 id="1-26-说一说String和StringBuffer有什么区别"><a href="#1-26-说一说String和StringBuffer有什么区别" class="headerlink" title="1.26 说一说String和StringBuffer有什么区别"></a>1.26 说一说String和StringBuffer有什么区别</h4><p>​<strong>参考答案</strong></p><p>​String类是不可变类，即一旦一个String对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。</p><p>​StringBuffer对象则代表一个字符序列可变的字符串，当一个StringBuffer被创建以后，通过StringBuffer提供的append()、insert()、reverse()、setCharAt()、setLength()等方法可以改变这个字符串对象的字符序列。一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个String对象。</p><h4 id="1-27-说一说StringBuffer和StringBuilder有什么区别"><a href="#1-27-说一说StringBuffer和StringBuilder有什么区别" class="headerlink" title="1.27 说一说StringBuffer和StringBuilder有什么区别"></a>1.27 说一说StringBuffer和StringBuilder有什么区别</h4><p>​<strong>参考答案</strong></p><p>​StringBuffer、StringBuilder都代表可变的字符串对象，它们有共同的父类 AbstractStringBuilder，并且两个类的构造方法和成员方法也基本相同。不同的是，StringBuffer是线程安全的，而StringBuilder是非线程安全的，所以StringBuilder性能略高。一般情况下，要创建一个内容可变的字符串，建议优先考虑StringBuilder类。</p><h4 id="1-28-使用字符串时，new和””推荐使用哪种方式？"><a href="#1-28-使用字符串时，new和””推荐使用哪种方式？" class="headerlink" title="1.28 使用字符串时，new和””推荐使用哪种方式？"></a>1.28 使用字符串时，new和””推荐使用哪种方式？</h4><p>​<strong>参考答案</strong></p><p>​先看看 “hello” 和 new String(“hello”) 的区别：</p><ul><li>​当Java程序直接使用 “hello” 的字符串直接量时，JVM将会使用常量池来管理这个字符串； </li><li>​当使用 new String(“hello”) 时，JVM会先使用常量池来管理 “hello” 直接量，再调用String类的构造器来创建一个新的String对象，新创建的String对象被保存在堆内存中。</li></ul><p> </p><p>​显然，采用new的方式会多创建一个对象出来，会占用更多的内存，所以一般建议使用直接量的方式创建字符串。</p><h4 id="1-29-说一说你对字符串拼接的理解"><a href="#1-29-说一说你对字符串拼接的理解" class="headerlink" title="1.29 说一说你对字符串拼接的理解"></a>1.29 说一说你对字符串拼接的理解</h4><p>​<strong>参考答案</strong></p><p>​拼接字符串有很多种方式，其中最常用的有4种，下面列举了这4种方式各自适合的场景。</p><ol><li>​+ 运算符：如果拼接的都是字符串直接量，则适合使用 + 运算符实现拼接； </li><li>​StringBuilder：如果拼接的字符串中包含变量，并不要求线程安全，则适合使用StringBuilder； </li><li>​StringBuffer：如果拼接的字符串中包含变量，并且要求线程安全，则适合使用StringBuffer； </li><li>​String类的concat方法：如果只是对两个字符串进行拼接，并且包含变量，则适合使用concat方法；</li></ol><p> </p><p>​<strong>扩展阅读</strong></p><p>​采用 + 运算符拼接字符串时：</p><ul><li>​如果拼接的都是字符串直接量，则在编译时编译器会将其直接优化为一个完整的字符串，和你直接写一个完整的字符串是一样的，所以效率非常的高。 </li><li>​如果拼接的字符串中包含变量，则在编译时编译器采用StringBuilder对其进行优化，即自动创建StringBuilder实例并调用其append()方法，将这些字符串拼接在一起，效率也很高。但如果这个拼接操作是在循环中进行的，那么每次循环编译器都会创建一个StringBuilder实例，再去拼接字符串，相当于执行了 new StringBuilder().append(str)，所以此时效率很低。</li></ul><p> </p><p>​采用StringBuilder&#x2F;StringBuffer拼接字符串时：</p><ul><li>​StringBuilder&#x2F;StringBuffer都有字符串缓冲区，缓冲区的容量在创建对象时确定，并且默认为16。当拼接的字符串超过缓冲区的容量时，会触发缓冲区的扩容机制，即缓冲区加倍。 </li><li>​缓冲区频繁的扩容会降低拼接的性能，所以如果能提前预估最终字符串的长度，则建议在创建可变字符串对象时，放弃使用默认的容量，可以指定缓冲区的容量为预估的字符串的长度。</li></ul><p> </p><p>​采用String类的concat方法拼接字符串时：</p><ul><li>​concat方法的拼接逻辑是，先创建一个足以容纳待拼接的两个字符串的字节数组，然后先后将两个字符串拼到这个数组里，最后将此数组转换为字符串。 </li><li>​在拼接大量字符串的时候，concat方法的效率低于StringBuilder。但是只拼接2个字符串时，concat方法的效率要优于StringBuilder。并且这种拼接方式代码简洁，所以只拼2个字符串时建议优先选择concat方法。</li></ul><p> </p><h4 id="1-30-两个字符串相加的底层是如何实现的？"><a href="#1-30-两个字符串相加的底层是如何实现的？" class="headerlink" title="1.30 两个字符串相加的底层是如何实现的？"></a>1.30 两个字符串相加的底层是如何实现的？</h4><p>​<strong>参考答案</strong></p><p>​如果拼接的都是字符串直接量，则在编译时编译器会将其直接优化为一个完整的字符串，和你直接写一个完整的字符串是一样的。</p><p>​如果拼接的字符串中包含变量，则在编译时编译器采用StringBuilder对其进行优化，即自动创建StringBuilder实例并调用其append()方法，将这些字符串拼接在一起。</p><h4 id="1-31-String-a-x3D-“abc”-，说一下这个过程会创建什么，放在哪里？"><a href="#1-31-String-a-x3D-“abc”-，说一下这个过程会创建什么，放在哪里？" class="headerlink" title="1.31 String a &#x3D; “abc”; ，说一下这个过程会创建什么，放在哪里？"></a>1.31 String a &#x3D; “abc”; ，说一下这个过程会创建什么，放在哪里？</h4><p>​<strong>参考答案</strong></p><p>​JVM会使用常量池来管理字符串直接量。在执行这句话时，JVM会先检查常量池中是否已经存有”abc”，若没有则将”abc”存入常量池，否则就复用常量池中已有的”abc”，将其引用赋值给变量a。</p><h4 id="1-32-new-String-“abc”-是去了哪里，仅仅是在堆里面吗？"><a href="#1-32-new-String-“abc”-是去了哪里，仅仅是在堆里面吗？" class="headerlink" title="1.32 new String(“abc”) 是去了哪里，仅仅是在堆里面吗？"></a>1.32 new String(“abc”) 是去了哪里，仅仅是在堆里面吗？</h4><p>​<strong>参考答案</strong></p><p>​在执行这句话时，JVM会先使用常量池来管理字符串直接量，即将”abc”存入常量池。然后再创建一个新的String对象，这个对象会被保存在堆内存中。并且，堆中对象的数据会指向常量池中的直接量。</p><h4 id="1-33-接口和抽象类有什么区别？"><a href="#1-33-接口和抽象类有什么区别？" class="headerlink" title="1.33 接口和抽象类有什么区别？"></a>1.33 接口和抽象类有什么区别？</h4><p>​<strong>参考答案</strong></p><p>​从设计目的上来说，二者有如下的区别：</p><p>​接口体现的是一种规范。对于接口的实现者而言，接口规定了实现者必须向外提供哪些服务；对于接口的调用者而言，接口规定了调用者可以调用哪些服务，以及如何调用这些服务。当在一个程序中使用接口时，接口是多个模块间的耦合标准；当在多个应用程序之间使用接口时，接口是多个程序之间的通信标准。</p><p>​抽象类体现的是一种模板式设计。抽象类作为多个子类的抽象父类，可以被当成系统实现过程中的中间产品，这个中间产品已经实现了系统的部分功能，但这个产品依然不能当成最终产品，必须有更进一步的完善，这种完善可能有几种不同方式。</p><p>​从使用方式上来说，二者有如下的区别：</p><ul><li>​接口里只能包含抽象方法、静态方法、默认方法和私有方法，不能为普通方法提供方法实现；抽象类则完全可以包含普通方法。 </li><li>​接口里只能定义静态常量，不能定义普通成员变量；抽象类里则既可以定义普通成员变量，也可以定义静态常量。 </li><li>​接口里不包含构造器；抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。 </li><li>​接口里不能包含初始化块；但抽象类则完全可以包含初始化块。 </li><li>​一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足。</li></ul><p> </p><p>​<strong>扩展阅读</strong></p><p>​接口和抽象类很像，它们都具有如下共同的特征：</p><ul><li>​接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。 </li><li>​接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。</li></ul><p> </p><h4 id="1-34-接口中可以有构造函数吗？"><a href="#1-34-接口中可以有构造函数吗？" class="headerlink" title="1.34 接口中可以有构造函数吗？"></a>1.34 接口中可以有构造函数吗？</h4><p>​<strong>参考答案</strong></p><p>​由于接口定义的是一种规范，因此接口里不能包含构造器和初始化块定义。接口里可以包含成员变量（只能是静态常量）、方法（只能是抽象实例方法、类方法、默认方法或私有方法）、内部类（包括内部接口、枚举）定义。</p><h4 id="1-35-谈谈你对面向接口编程的理解"><a href="#1-35-谈谈你对面向接口编程的理解" class="headerlink" title="1.35 谈谈你对面向接口编程的理解"></a>1.35 谈谈你对面向接口编程的理解</h4><p>​<strong>参考答案</strong></p><p>​接口体现的是一种规范和实现分离的设计哲学，充分利用接口可以极好地降低程序各模块之间的耦合，从而提高系统的可扩展性和可维护性。基于这种原则，很多软件架构设计理论都倡导“面向接口”编程，而不是面向实现类编程，希望通过面向接口编程来降低程序的耦合。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题整理-JavaSE-2</title>
      <link href="/2021/10/20/Java-2/"/>
      <url>/2021/10/20/Java-2/</url>
      
        <content type="html"><![CDATA[<h4 id="1-11-int和Integer有什么区别，二者在做-x3D-x3D-运算时会得到什么结果？"><a href="#1-11-int和Integer有什么区别，二者在做-x3D-x3D-运算时会得到什么结果？" class="headerlink" title="1.11 int和Integer有什么区别，二者在做&#x3D;&#x3D;运算时会得到什么结果？"></a>1.11 int和Integer有什么区别，二者在做&#x3D;&#x3D;运算时会得到什么结果？</h4><p>​<strong>参考答案</strong></p><p>​int是基本数据类型，Integer是int的包装类。二者在做&#x3D;&#x3D;运算时，Integer会自动拆箱为int类型，然后再进行比较。届时，如果两个int值相等则返回true，否则就返回false。</p><h4 id="1-12-说一说你对面向对象的理解"><a href="#1-12-说一说你对面向对象的理解" class="headerlink" title="1.12 说一说你对面向对象的理解"></a>1.12 说一说你对面向对象的理解</h4><p>​<strong>参考答案</strong></p><p>​面向对象是一种更优秀的程序设计方法，它的基本思想是使用类、对象、继承、封装、消息等基本概念进行程序设计。它从现实世界中客观存在的事物出发来构造软件系统，并在系统构造中尽可能运用人类的自然思维方式，强调直接以现实世界中的事物为中心来思考，认识问题，并根据这些事物的本质特点，把它们抽象地表示为系统中的类，作为系统的基本构成单元，这使得软件系统的组件可以直接映像到客观世界，并保持客观世界中事物及其相互关系的本来面貌。</p><p>​<strong>扩展阅读</strong></p><p>​结构化程序设计方法主张按功能来分析系统需求，其主要原则可概括为自顶向下、逐步求精、模块化等。结构化程序设计首先采用结构化分析方法对系统进行需求分析，然后使用结构化设计方法对系统进行概要设计、详细设计，最后采用结构化编程方法来实现系统。</p><p>​因为结构化程序设计方法主张按功能把软件系统逐步细分，因此这种方法也被称为面向功能的程序设计方法；结构化程序设计的每个功能都负责对数据进行一次处理，每个功能都接受一些数据，处理完后输出一些数据，这种处理方式也被称为面向数据流的处理方式。</p><p>​结构化程序设计里最小的程序单元是函数，每个函数都负责完成一个功能，用以接收一些输入数据，函数对这些输入数据进行处理，处理结束后输出一些数据。整个软件系统由一个个函数组成，其中作为程序入口的函数被称为主函数，主函数依次调用其他普通函数，普通函数之间依次调用，从而完成整个软件系统的功能。</p><p>​每个函数都是具有输入、输出的子系统，函数的输入数据包括函数形参、全局变量和常量等，函数的输出数据包括函数返回值以及传出参数等。结构化程序设计方式有如下两个局限性：</p><ul><li>​设计不够直观，与人类习惯思维不一致。采用结构化程序分析、设计时，开发者需要将客观世界模型分解成一个个功能，每个功能用以完成一定的数据处理。 </li><li>​适应性差，可扩展性不强。由于结构化设计采用自顶向下的设计方式，所以当用户的需求发生改变，或需要修改现有的实现方式时，都需要自顶向下地修改模块结构，这种方式的维护成本相当高。</li></ul><p> </p><h4 id="1-13-面向对象的三大特征是什么？"><a href="#1-13-面向对象的三大特征是什么？" class="headerlink" title="1.13 面向对象的三大特征是什么？"></a>1.13 面向对象的三大特征是什么？</h4><p>​<strong>参考答案</strong></p><p>​面向对象的程序设计方法具有三个基本特征：封装、继承、多态。其中，封装指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能；继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法；多态指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征。</p><p>​<strong>扩展阅读</strong></p><p>​抽象也是面向对象的重要部分，抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是考虑部分问题。例如，需要考察Person对象时，不可能在程序中把Person的所有细节都定义出来，通常只能定义Person的部分数据、部分行为特征，而这些数据、行为特征是软件系统所关心的部分。</p><h4 id="1-14-封装的目的是什么，为什么要有封装？"><a href="#1-14-封装的目的是什么，为什么要有封装？" class="headerlink" title="1.14 封装的目的是什么，为什么要有封装？"></a>1.14 封装的目的是什么，为什么要有封装？</h4><p>​<strong>参考答案</strong></p><p>​封装是面向对象编程语言对客观世界的模拟，在客观世界里，对象的状态信息都被隐藏在对象内部，外界无法直接操作和修改。对一个类或对象实现良好的封装，可以实现以下目的：</p><ul><li>​隐藏类的实现细节； </li><li>​让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问； </li><li>​可进行数据检查，从而有利于保证对象信息的完整性； </li><li>​便于修改，提高代码的可维护性。</li></ul><p> </p><p>​<strong>扩展阅读</strong></p><p>​为了实现良好的封装，需要从两个方面考虑：</p><ul><li>​将对象的成员变量和实现细节隐藏起来，不允许外部直接访问； </li><li>​把方法暴露出来，让方法来控制对这些成员变量进行安全的访问和操作。</li></ul><p> </p><p>​封装实际上有两个方面的含义：把该隐藏的隐藏起来，把该暴露的暴露出来。这两个方面都需要通过使用Java提供的访问控制符来实现。</p><h4 id="1-15-说一说你对多态的理解"><a href="#1-15-说一说你对多态的理解" class="headerlink" title="1.15 说一说你对多态的理解"></a>1.15 说一说你对多态的理解</h4><p>​<strong>参考答案</strong></p><p>​因为子类其实是一种特殊的父类，因此Java允许把一个子类对象直接赋给一个父类引用变量，无须任何类型转换，或者被称为向上转型，向上转型由系统自动完成。</p><p>​当把一个子类对象直接赋给父类引用变量时，例如 BaseClass obj &#x3D; new SubClass();，这个obj引用变量的编译时类型是BaseClass，而运行时类型是SubClass，当运行时调用该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，这就可能出现：相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，这就是多态。</p><p>​</p><p>​<strong>扩展阅读</strong></p><p>​多态可以提高程序的可扩展性，在设计程序时让代码更加简洁而优雅。</p><p>​例如我要设计一个司机类，他可以开轿车、巴士、卡车等等，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Driver</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">(Car car)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">(Bus bus)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">(Truck truck)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在设计上述代码时，我已采用了重载机制，将方法名进行了统一。这样在进行调用时，无论要开什么交通工具，都是通过driver.drive(obj)这样的方式来调用，对调用者足够的友好。</p><p>​但对于程序的开发者来说，这显得繁琐，因为实际上这个司机可以驾驶更多的交通工具。当系统需要为这个司机增加车型时，开发者就需要相应的增加driver方法，类似的代码会堆积的越来越多，显得臃肿。</p><p>​</p><p>​采用多态的方式来设计上述程序，就会变得简洁很多。我们可以为所有的交通工具定义一个父类Vehicle，然后按照如下的方式设计drive方法。调用时，我们可以传入Vehicle类型的实例，也可以传入任意的Vehicle子类型的实例，对于调用者来说一样的方便，但对于开发者来说，代码却变得十分的简洁了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Driver</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">(Vehicle vehicle)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-16-Java中的多态是怎么实现的？"><a href="#1-16-Java中的多态是怎么实现的？" class="headerlink" title="1.16 Java中的多态是怎么实现的？"></a>1.16 Java中的多态是怎么实现的？</h4><p>​<strong>参考答案</strong></p><p>​多态的实现离不开继承，在设计程序时，我们可以将参数的类型定义为父类型。在调用程序时，则可以根据实际情况，传入该父类型的某个子类型的实例，这样就实现了多态。对于父类型，可以有三种形式，即普通的类、抽象类、接口。对于子类型，则要根据它自身的特征，重写父类的某些方法，或实现抽象类&#x2F;接口的某些抽象方法。</p><h4 id="1-17-Java为什么是单继承，为什么不能多继承？"><a href="#1-17-Java为什么是单继承，为什么不能多继承？" class="headerlink" title="1.17 Java为什么是单继承，为什么不能多继承？"></a>1.17 Java为什么是单继承，为什么不能多继承？</h4><p>​<strong>参考答案</strong></p><p>​首先，Java是单继承的，指的是Java中一个类只能有一个直接的父类。Java不能多继承，则是说Java中一个类不能直接继承多个父类。</p><p>​其次，Java在设计时借鉴了C++的语法，而C++是支持多继承的。Java语言之所以摒弃了多继承的这项特征，是因为多继承容易产生混淆。比如，两个父类中包含相同的方法时，子类在调用该方法或重写该方法时就会迷惑。</p><p>​准确来说，Java是可以实现”多继承”的。因为尽管一个类只能有一个直接父类，但是却可以有任意多个间接的父类。这样的设计方式，避免了多继承时所产生的混淆。</p><h4 id="1-18-说一说重写与重载的区别"><a href="#1-18-说一说重写与重载的区别" class="headerlink" title="1.18 说一说重写与重载的区别"></a>1.18 说一说重写与重载的区别</h4><p>​<strong>参考答案</strong></p><p>​重载发生在同一个类中，若多个方法之间方法名相同、参数列表不同，则它们构成重载的关系。重载与方法的返回值以及访问修饰符无关，即重载的方法不能根据返回类型进行区分。</p><p>​重写发生在父类子类中，若子类方法想要和父类方法构成重写关系，则它的方法名、参数列表必须与父类方法相同。另外，返回值要小于等于父类方法，抛出的异常要小于等于父类方法，访问修饰符则要大于等于父类方法。还有，若父类方法的访问修饰符为private，则子类不能对其重写。</p><h4 id="1-19-构造方法能不能重写？"><a href="#1-19-构造方法能不能重写？" class="headerlink" title="1.19 构造方法能不能重写？"></a>1.19 构造方法能不能重写？</h4><p>​<strong>参考答案</strong></p><p>​构造方法不能重写。因为构造方法需要和类保持同名，而重写的要求是子类方法要和父类方法保持同名。如果允许重写构造方法的话，那么子类中将会存在与类名不同的构造方法，这与构造方法的要求是矛盾的。</p><h4 id="1-20-介绍一下Object类中的方法"><a href="#1-20-介绍一下Object类中的方法" class="headerlink" title="1.20 介绍一下Object类中的方法"></a>1.20 介绍一下Object类中的方法</h4><p>​<strong>参考答案</strong></p><p>​Object类提供了如下几个常用方法：</p><ul><li>​Class&lt;?&gt; getClass()：返回该对象的运行时类。 </li><li>​boolean equals(Object obj)：判断指定对象与该对象是否相等。 </li><li>​int hashCode()：返回该对象的hashCode值。在默认情况下，Object类的hashCode()方法根据该对象的地址来计算。但很多类都重写了Object类的hashCode()方法，不再根据地址来计算其hashCode()方法值。 </li><li>​String toString()：返回该对象的字符串表示，当程序使用System.out.println()方法输出一个对象，或者把某个对象和字符串进行连接运算时，系统会自动调用该对象的toString()方法返回该对象的字符串表示。Object类的toString()方法返回 运行时类名@十六进制hashCode值 格式的字符串，但很多类都重写了Object类的toString()方法，用于返回可以表述该对象信息的字符串。</li></ul><p> </p><p>​另外，Object类还提供了wait()、notify()、notifyAll()这几个方法，通过这几个方法可以控制线程的暂停和运行。Object类还提供了一个clone()方法，该方法用于帮助其他对象来实现“自我克隆”，所谓“自我克隆”就是得到一个当前对象的副本，而且二者之间完全隔离。由于该方法使用了protected修饰，因此它只能被子类重写或调用。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题整理-JavaSE-1</title>
      <link href="/2021/10/20/Java-1/"/>
      <url>/2021/10/20/Java-1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Java基础"><a href="#1-Java基础" class="headerlink" title="1. Java基础"></a>1. Java基础</h2><h4 id="1-1-为什么Java代码可以实现一次编写、到处运行？"><a href="#1-1-为什么Java代码可以实现一次编写、到处运行？" class="headerlink" title="1.1 为什么Java代码可以实现一次编写、到处运行？"></a>1.1 为什么Java代码可以实现一次编写、到处运行？</h4><p>​<strong>参考答案</strong></p><p>​JVM（Java虚拟机）是Java跨平台的关键。</p><p>​在程序运行前，Java源代码（.java）需要经过编译器编译成字节码（.class）。在程序运行时，JVM负责将字节码翻译成特定平台下的机器码并运行，也就是说，只要在不同的平台上安装对应的JVM，就可以运行字节码文件。</p><p>​同一份Java源代码在不同的平台上运行，它不需要做任何的改变，并且只需要编译一次。而编译好的字节码，是通过JVM这个中间的“桥梁”实现跨平台的，JVM是与平台相关的软件，它能将统一的字节码翻译成该平台的机器码。</p><p>​<strong>注意事项</strong></p><ol><li>​编译的结果是生成字节码、不是机器码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行； </li><li>​跨平台的是Java程序、而不是JVM，JVM是用C&#x2F;C++开发的软件，不同平台下需要安装不同版本的JVM。</li></ol><p> </p><h4 id="1-2-一个Java文件里可以有多个类吗（不含内部类）？"><a href="#1-2-一个Java文件里可以有多个类吗（不含内部类）？" class="headerlink" title="1.2 一个Java文件里可以有多个类吗（不含内部类）？"></a>1.2 一个Java文件里可以有多个类吗（不含内部类）？</h4><p>​<strong>参考答案</strong></p><ol><li>​一个java文件里可以有多个类，但最多只能有一个被public修饰的类； </li><li>​如果这个java文件中包含public修饰的类，则这个类的名称必须和java文件名一致。</li></ol><p> </p><h4 id="1-3-说一说你对Java访问权限的了解"><a href="#1-3-说一说你对Java访问权限的了解" class="headerlink" title="1.3 说一说你对Java访问权限的了解"></a>1.3 说一说你对Java访问权限的了解</h4><p>​<strong>参考答案</strong></p><p>​Java语言为我们提供了三种访问修饰符，即private、protected、public，在使用这些修饰符修饰目标时，一共可以形成四种访问权限，即private、default、protected、public，注意在不加任何修饰符时为default访问权限。</p><p>​在修饰成员变量&#x2F;成员方法时，该成员的四种访问权限的含义如下：</p><ul><li>​private：该成员可以被该类内部成员访问； </li><li>​default：该成员可以被该类内部成员访问，也可以被同一包下其他的类访问； </li><li>​protected：该成员可以被该类内部成员访问，也可以被同一包下其他的类访问，还可以被它的子类访问； </li><li>​public：该成员可以被任意包下，任意类的成员进行访问。</li></ul><p> </p><p>​在修饰类时，该类只有两种访问权限，对应的访问权限的含义如下：</p><ul><li>​default：该类可以被同一包下其他的类访问； </li><li>​public：该类可以被任意包下，任意的类所访问。</li></ul><p> </p><h4 id="1-4-介绍一下Java的数据类型"><a href="#1-4-介绍一下Java的数据类型" class="headerlink" title="1.4 介绍一下Java的数据类型"></a>1.4 介绍一下Java的数据类型</h4><p>​<strong>参考答案</strong></p><p>​Java数据类型包括基本数据类型和引用数据类型两大类。</p><p>​基本数据类型有8个，可以分为4个小类，分别是整数类型（byte&#x2F;short&#x2F;int&#x2F;long）、浮点类型（float&#x2F;double）、字符类型（char）、布尔类型（boolean）。其中，4个整数类型中，int类型最为常用。2个浮点类型中，double最为常用。另外，在这8个基本类型当中，除了布尔类型之外的其他7个类型，都可以看做是数字类型，它们相互之间可以进行类型转换。</p><p>​引用类型就是对一个对象的引用，根据引用对象类型的不同，可以将引用类型分为3类，即数组、类、接口类型。引用类型本质上就是通过指针，指向堆中对象所持有的内存空间，只是Java语言不再沿用指针这个说法而已。</p><p>​<strong>扩展阅读</strong></p><p>​对于基本数据类型，你需要了解每种类型所占据的内存空间，面试官可能会追问这类问题：</p><ul><li>​byte：1字节（8位），数据范围是 -2^7 ~ 2^7-1。 </li><li>​short：2字节（16位），数据范围是 -2^15 ~ 2^15-1。 </li><li>​int：4字节（32位），数据范围是 -2^31 ~ 2^31-1。 </li><li>​long：8字节（64位），数据范围是 -2^63 ~ 2^63-1。 </li><li>​float：4字节（32位），数据范围大约是 -3.4<em>10^38 ~ 3.4</em>10^38。  </li><li>​double：8字节（64位），数据范围大约是 -1.8<em>10^308 ~ 1.8</em>10^308。  </li><li>​char：2字节（16位），数据范围是 \u0000 ~ \uffff。 </li><li>​boolean：Java规范没有明确的规定，不同的JVM有不同的实现机制。</li></ul><p> </p><p>​对于引用数据类型，你需要了解JVM的内存分布情况，知道引用以及引用对象存放的位置，详见JVM部分的题目。</p><h4 id="1-5-int类型的数据范围是多少？"><a href="#1-5-int类型的数据范围是多少？" class="headerlink" title="1.5 int类型的数据范围是多少？"></a>1.5 int类型的数据范围是多少？</h4><p>​<strong>参考答案</strong></p><p>​int类型占4字节（32位），数据范围是 -2^31 ~ 2^31-1。</p><h4 id="1-6-请介绍全局变量和局部变量的区别"><a href="#1-6-请介绍全局变量和局部变量的区别" class="headerlink" title="1.6 请介绍全局变量和局部变量的区别"></a>1.6 请介绍全局变量和局部变量的区别</h4><p>​<strong>参考答案</strong></p><p>​Java中的变量分为成员变量和局部变量，它们的区别如下：</p><p>​成员变量：</p><ol><li>​成员变量是在类的范围里定义的变量； </li><li>​成员变量有默认初始值； </li><li>​未被static修饰的成员变量也叫实例变量，它存储于对象所在的堆内存中，生命周期与对象相同； </li><li>​被static修饰的成员变量也叫类变量，它存储于方法区中，生命周期与当前类相同。</li></ol><p> </p><p>​局部变量：</p><ol><li>​局部变量是在方法里定义的变量； </li><li>​局部变量没有默认初始值； </li><li>​局部变量存储于栈内存中，作用的范围结束，变量空间会自动的释放。</li></ol><p> </p><p>​<strong>注意事项</strong></p><p>​Java中没有真正的全局变量，面试官应该是出于其他语言的习惯说全局变量的，他的本意应该是指成员变量。</p><h4 id="1-7-请介绍一下实例变量的默认值"><a href="#1-7-请介绍一下实例变量的默认值" class="headerlink" title="1.7 请介绍一下实例变量的默认值"></a>1.7 请介绍一下实例变量的默认值</h4><p>​<strong>参考答案</strong></p><p>​实例变量若为引用数据类型，其默认值一律为null。若为基本数据类型，其默认值如下：</p><ul><li>​byte：0 </li><li>​short：0 </li><li>​int：0 </li><li>​long：0L </li><li>​float：0.0F </li><li>​double：0.0 </li><li>​char：’\u0000’ </li><li>​boolean：false</li></ul><p> </p><p>​<strong>注意事项</strong></p><p>​上述默认值规则适用于所有的成员变量，所以对于类变量也是适用的。</p><h4 id="1-8-为啥要有包装类？"><a href="#1-8-为啥要有包装类？" class="headerlink" title="1.8 为啥要有包装类？"></a>1.8 为啥要有包装类？</h4><p>​<strong>参考答案</strong></p><p>​Java语言是面向对象的语言，其设计理念是“一切皆对象”。但8种基本数据类型却出现了例外，它们不具备对象的特性。正是为了解决这个问题，Java为每个基本数据类型都定义了一个对应的引用类型，这就是包装类。</p><p>​<strong>扩展阅读</strong></p><p>​Java之所以提供8种基本数据类型，主要是为了照顾程序员的传统习惯。这8种基本数据类型的确带来了一定的方便性，但在某些时候也会受到一些制约。比如，所有的引用类型的变量都继承于Object类，都可以当做Object类型的变量使用，但基本数据类型却不可以。如果某个方法需要Object类型的参数，但实际传入的值却是数字的话，就需要做特殊的处理了。有了包装类，这种问题就可以得以简化。</p><h4 id="1-9-说一说自动装箱、自动拆箱的应用场景"><a href="#1-9-说一说自动装箱、自动拆箱的应用场景" class="headerlink" title="1.9 说一说自动装箱、自动拆箱的应用场景"></a>1.9 说一说自动装箱、自动拆箱的应用场景</h4><p>​<strong>参考答案</strong></p><p>​自动装箱、自动拆箱是JDK1.5提供的功能。</p><p>​自动装箱：可以把一个基本类型的数据直接赋值给对应的包装类型；</p><p>​自动拆箱：可以把一个包装类型的对象直接赋值给对应的基本类型；</p><p>​通过自动装箱、自动拆箱功能，可以大大简化基本类型变量和包装类对象之间的转换过程。比如，某个方法的参数类型为包装类型，调用时我们所持有的数据却是基本类型的值，则可以不做任何特殊的处理，直接将这个基本类型的值传入给方法即可。</p><h4 id="1-10-如何对Integer和Double类型判断相等？"><a href="#1-10-如何对Integer和Double类型判断相等？" class="headerlink" title="1.10 如何对Integer和Double类型判断相等？"></a>1.10 如何对Integer和Double类型判断相等？</h4><p>​<strong>参考答案</strong></p><p>​Integer、Double不能直接进行比较，这包括：</p><ul><li>​不能用&#x3D;&#x3D;进行直接比较，因为它们是不同的数据类型； </li><li>​不能转为字符串进行比较，因为转为字符串后，浮点值带小数点，整数值不带，这样它们永远都不相等； </li><li>​不能使用compareTo方法进行比较，虽然它们都有compareTo方法，但该方法只能对相同类型进行比较。</li></ul><p> </p><p>​整数、浮点类型的包装类，都继承于Number类型，而Number类型分别定义了将数字转换为byte、short、int、long、float、double的方法。所以，可以将Integer、Double先转为转换为相同的基本数据类型（如double），然后使用&#x3D;&#x3D;进行比较。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Test(JavaWeb)</title>
      <link href="/2021/10/20/test%20copy%202/"/>
      <url>/2021/10/20/test%20copy%202/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暂时放着</title>
      <link href="/2021/10/20/test%20copy%203/"/>
      <url>/2021/10/20/test%20copy%203/</url>
      
        <content type="html"><![CDATA[<p>不知道会更新什么，也许是什么杂谈，模型教程(，一些乱七八糟的东西</p>]]></content>
      
      
      <categories>
          
          <category> 建设中 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
